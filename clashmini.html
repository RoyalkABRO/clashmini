<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Clash Arena 10.0 (Final Deck)</title> <!-- –û–Ω–æ–≤–ª–µ–Ω–æ –≤–µ—Ä—Å—ñ—é -->
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 2. Custom styles for the game */
        html, body {
            font-family: 'Inter', sans-serif;
            background-color: #0c1c3a; /* Dark blue bg */
            color: white;
            overflow: hidden;
            touch-action: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        /* --- Base Container --- */
        .screen {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            max-width: 500px; /* Constrain width like a phone */
            max-height: 900px; /* Constrain height */
            margin: auto;
            border: 4px solid #1a1a1a;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        /* --- Main Menu Screen (NEW UI based on screenshot) --- */
        #main-menu-screen {
            background-color: #1a73e8; /* Base blue */
            /* Tiled background pattern */
            background-image: 
                linear-gradient(135deg, rgba(255, 255, 255, 0.05) 25%, transparent 25%),
                linear-gradient(225deg, rgba(255, 255, 255, 0.05) 25%, transparent 25%),
                linear-gradient(45deg, rgba(255, 255, 255, 0.05) 25%, transparent 25%),
                linear-gradient(315deg, rgba(255, 255, 255, 0.05) 25%, #1a73e8 25%);
            background-size: 40px 40px;
            justify-content: space-between;
        }
        
        /* Top Bar (NEW DESIGN based on image_38c741.png) */
        .menu-top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10;
        }
        .menu-top-left {
            display: flex;
            align-items: center;
            background: rgba(0,0,0,0.3);
            border-radius: 16px;
            padding: 4px 8px;
        }
        .menu-level-badge {
            background: #1d4ed8;
            border: 2px solid #60a5fa;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 700;
            margin-right: 4px;
        }
        .menu-xp-bar {
            width: 60px;
            height: 10px;
            background: #555;
            border-radius: 5px;
            overflow: hidden;
        }
        .menu-xp-bar div { height: 100%; width: 20%; background: #22c55e; }
        
        .menu-top-right {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .menu-currency-box {
            display: flex;
            align-items: center;
            background: rgba(0,0,0,0.3);
            border-radius: 16px;
            padding: 4px 8px;
            font-weight: 600;
        }
        .menu-currency-box svg { width: 20px; height: 20px; margin-right: 4px; }
        
        /* Top right buttons */
        .menu-top-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
            position: absolute;
            top: 55px; /* Below currency */
            right: 12px;
            z-index: 10;
        }
        .menu-icon-button {
            width: 44px;
            height: 44px;
            background: #1d4ed8;
            border-radius: 8px;
            border: 2px solid #60a5fa;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .menu-icon-button svg { width: 28px; height: 28px; }
        .notification-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #ef4444;
            color: white;
            font-size: 12px;
            font-weight: 700;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
        }

        /* --- NEW: Tab Content Area --- */
        .tab-content {
            padding-top: 110px; /* Make space for top bars */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            /* Allow scrolling on card list */
            overflow-y: auto; 
            height: 100%; /* Take full height */
            padding-bottom: 80px; /* Space for bottom nav */
        }
        
        /* --- NEW: Shop Styles --- */
        #tab-content-shop {
            padding: 0; /* Override default tab padding */
            padding-top: 110px;
            background-color: #1a73e8; /* Re-apply base blue */
            /* Re-apply tiled background pattern */
            background-image: 
                linear-gradient(135deg, rgba(255, 255, 255, 0.05) 25%, transparent 25%),
                linear-gradient(225deg, rgba(255, 255, 255, 0.05) 25%, transparent 25%),
                linear-gradient(45deg, rgba(255, 255, 255, 0.05) 25%, transparent 25%),
                linear-gradient(315deg, rgba(255, 255, 255, 0.05) 25%, #1a73e8 25%);
            background-size: 40px 40px;
            padding-bottom: 90px; /* SCROLL FIX: Add padding to bottom */
        }
        .shop-section {
            width: 100%;
            padding: 0 12px 16px 12px;
        }
        .shop-section-header {
            width: 100%;
            background: #d946ef; /* Pink/Purple */
            color: white;
            font-size: 20px;
            font-weight: 700;
            text-align: center;
            padding: 8px;
            border-radius: 8px;
            margin-bottom: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .shop-item {
            background: linear-gradient(145deg, #4b5563, #374151);
            border: 3px solid #94a3b8;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        /* NEW: Purchased State */
        .shop-item.purchased {
            filter: grayscale(80%);
            opacity: 0.7;
        }
        .shop-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.5);
        }
        .shop-item-title {
            font-size: 13px;
            font-weight: 700;
            text-align: center;
            color: #fff;
            margin-bottom: 4px;
            height: 30px; /* Ensure 2 lines max */
            overflow: hidden;
        }
        .shop-item-image-container {
            width: 100%;
            height: 80px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px;
            margin-bottom: 8px;
        }
        .shop-item-image-container img {
            width: auto;
            height: 100%;
            max-width: 100%;
            object-fit: contain;
        }
        /* Updated for SVG */
        .shop-item-image-container .card-image {
            width: 100%;
            height: 100%;
            padding: 4px;
        }
        .shop-item-image-container .card-image svg {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 5px;
        }
        
        .shop-item-price {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 700;
            gap: 4px;
            background: #1e40af;
            color: white;
            padding: 4px 10px;
            border-radius: 20px;
            border: 2px solid #60a5fa;
            width: 100%;
        }
        .shop-item-price.free {
            background: #16a34a; /* Green for free */
            border-color: #86efac;
        }
        .shop-item-price.gem {
            background: #0d9488;
            border-color: #5eead4;
        }
        .shop-item-price svg {
            width: 16px;
            height: 16px;
        }
        .shop-item-price.uah {
            font-size: 14px;
            background: #16a34a;
            border-color: #86efac;
        }
        /* NEW: Purchased Button Style */
        .shop-item-price.purchased-btn {
            background: #22c55e;
            border-color: #86efac;
            font-size: 14px;
        }

        /* Battle Button */
        #play-button {
            width: 200px;
            padding: 16px;
            font-size: 28px;
            font-weight: 900;
            color: #4a2a0a;
            /* Gold/Yellow color */
            background: linear-gradient(180deg, #fcd34d 0%, #fbbf24 100%);
            border-radius: 16px; 
            text-align: center;
            border-bottom: 6px solid #b45309;
            box-shadow: 0 5px 15px rgba(251, 191, 36, 0.4);
            cursor: pointer;
            transition: all 0.1s ease;
            text-shadow: 0 1px 1px rgba(255,255,255,0.5);
        }
        #play-button:active {
            transform: translateY(2px);
            border-bottom-width: 4px;
            box-shadow: 0 2px 10px rgba(251, 191, 36, 0.4);
        }
        
        /* Player Banner (v8.1) */
        .menu-player-banner {
            background: linear-gradient(135deg, #06b6d4, #0e7490);
            border-radius: 12px;
            padding: 8px 16px;
            text-align: center;
            border: 2px solid #67e8f9;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .menu-player-banner .name { 
            font-size: 20px; 
            font-weight: 700;
            text-shadow: 1px 1px #083344;
        }
        .menu-player-banner .clan {
            font-size: 14px;
            color: #cffafe;
            text-shadow: 1px 1px #083344;
        }
        .menu-player-banner .trophies { 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            gap: 4px; 
            font-size: 16px; 
            color: #f59e0b; 
            font-weight: 600;
            margin-top: 4px;
        }
        
        .menu-arena-art {
            width: 220px;
            height: 165px;
            background-color: #2e7d32; /* Green grass */
            border: 4px solid #8d6e63; /* Brown border */
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            overflow: hidden;
            position: relative;
        }
        .menu-arena-art svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Chest Slots */
        .menu-chest-slots {
            display: flex;
            justify-content: space-around;
            gap: 8px;
            padding: 0 16px;
            margin-top: 24px;
        }
        .chest-slot {
            width: 70px;
            height: 85px;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: #aaa;
            font-size: 10px;
        }
        .chest-slot.filled {
            background: #854d0e;
            border-color: #fcd34d;
            font-size: 28px;
        }

        /* --- NEW: Card Collection Grid Styles --- */
        #card-collection-grid {
            width: 100%;
            max-width: 400px; /* Constrain grid width */
            padding-top: 20px;
            padding-bottom: 20px;
        }
        /* Re-use .card style for collection */
        .card {
            width: 75px;
            height: 110px;
            background-color: #f0f0f0;
            border: 3px solid #fff;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 4px;
            transition: all 0.15s ease;
            position: relative;
            background: linear-gradient(145deg, #e0e0e0, #c0c0c0);
            color: #333;
            font-weight: bold;
            margin: auto; /* Center in grid cell */
            cursor: pointer;
        }
        
        /* --- NEW: SVG Card Image Style --- */
        .card-image {
            width: 100%;
            height: 70px;
            padding: 4px;
            border-radius: 5px;
            margin-top: 4px;
        }
        .card-image svg {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        .card-cost {
            position: absolute;
            top: -5px;
            left: -5px;
            background-color: #a800a8;
            color: white;
            font-size: 16px;
            font-weight: bold;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .card-name { font-size: 11px; text-align: center; color: #111; }

        /* Bottom Nav */
        .menu-bottom-nav {
            display: flex;
            justify-content: space-around;
            align-items: center;
            background: #1e3a8a;
            padding: 8px 0;
            border-top: 2px solid #60a5fa;
            position: absolute; /* Stick to bottom */
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 20;
        }
        .menu-nav-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            font-size: 11px;
            font-weight: 600;
            color: #a5b4fc; 
            opacity: 0.7;
            width: 65px;
            padding-top: 4px;
            cursor: pointer;
        }
        .menu-nav-button.active {
            opacity: 1;
            color: #fff; 
            transform: scale(1.1);
        }
        .menu-nav-button.active .icon-bg {
            background: #2563eb;
        }
        .menu-nav-button .icon-bg {
            width: 50px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        .menu-nav-button.active .icon-bg svg {
            transform: scale(1.2);
        }
        .menu-nav-button svg { width: 28px; height: 28px; }


        /* --- NEW: Card Stats Popup (CSS FIX) --- */
        #card-stats-popup {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            z-index: 100;
            padding: 16px;
            /* BUG FIX: Removed display:flex. JS will add/remove 'hidden' and 'flex' classes. */
        }
        .popup-content {
            background: #e2e8f0; /* Light gray background */
            color: #1e293b; /* Dark text */
            width: 100%;
            max-width: 380px;
            border-radius: 12px;
            border: 4px solid #475569;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            padding: 12px;
            position: relative;
        }
        #popup-close-btn {
            position: absolute;
            top: -15px;
            right: -15px;
            width: 36px;
            height: 36px;
            background: #ef4444; /* Red */
            color: white;
            font-size: 24px;
            font-weight: bold;
            border-radius: 50%;
            border: 3px solid white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            line-height: 1;
        }
        .popup-header {
            display: flex;
            gap: 12px;
            padding-bottom: 12px;
            border-bottom: 2px solid #94a3b8;
        }
        #popup-card-preview {
            width: 90px;
            height: 132px;
            flex-shrink: 0;
        }
        .popup-info {
            display: flex;
            flex-direction: column;
            width: 100%;
        }
        #popup-card-name {
            font-size: 24px;
            font-weight: 900;
            color: #000;
        }
        .popup-rarity-bar {
            display: flex;
            background: #8b5cf6; /* Purple */
            color: white;
            font-weight: 600;
            border-radius: 6px;
            overflow: hidden;
            margin: 8px 0;
            text-transform: uppercase;
            font-size: 14px;
        }
        .popup-rarity-bar span {
            padding: 4px 8px;
            width: 50%;
            text-align: center;
        }
        .popup-rarity-bar span:first-child {
            border-right: 2px solid #a78bfa;
        }
        #popup-card-description {
            font-size: 13px;
            color: #334155;
            line-height: 1.4;
        }
        .popup-stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
        }
        .popup-stat-box {
            background: #cbd5e1;
            border-radius: 8px;
            padding: 8px;
            border: 2px solid #94a3b8;
        }
        .popup-stat-box .label {
            font-size: 12px;
            font-weight: 600;
            color: #475569;
            margin-bottom: 2px;
        }
        .popup-stat-box .value {
            font-size: 18px;
            font-weight: 700;
            color: #000;
        }
        
        /* === NEW: Deck Button Styles === */
        #popup-deck-button {
            /* Base styles are applied via Tailwind classes in JS */
        }
        #popup-deck-button.remove {
            background-color: #ef4444; /* Red */
            border-bottom-color: #b91c1c;
        }
        #popup-deck-button.remove:hover {
            background-color: #f87171;
        }
        #popup-deck-button:disabled {
            background-color: #9ca3af;
            border-bottom-color: #4b5563;
            cursor: not-allowed;
            opacity: 0.7;
        }
        /* === END: Deck Button Styles === */


        /* --- NEW: GEMINI API STYLES --- */
        #gemini-tips-button {
            width: 100%;
            background: linear-gradient(135deg, #8b5cf6, #6d28d9);
            color: white;
            font-weight: 700;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #c4b5fd;
            border-bottom: 4px solid #5b21b6;
            margin-top: 12px;
            cursor: pointer;
            transition: all 0.1s ease;
        }
        #gemini-tips-button:active {
            transform: translateY(1px);
            border-bottom-width: 2px;
        }
        #gemini-tips-button:disabled {
            background: #a78bfa;
            opacity: 0.7;
            cursor: wait;
        }
        #gemini-tips-result {
            background-color: #cbd5e1;
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            font-size: 14px;
            color: #1e293b;
            border: 2px solid #94a3b8;
        }
        #gemini-tips-result li {
            margin-left: 16px;
            list-style-type: disc;
            margin-bottom: 4px;
        }
        /* --- END GEMINI STYLES --- */


        /* --- NEW: Card Rarity Borders --- */
        .rarity-common { border-color: #a0aec0; } /* Pale Blue/Grey */
        .rarity-rare { border-color: #f59e0b; } /* Orange */
        .rarity-epic { border-color: #a855f7; } /* Purple */
        .rarity-champion { border-color: #facc15; } /* Bright Yellow */
        
        .rarity-legendary {
            border-image-source: linear-gradient(to bottom right, #facc15, #ef4444, #a855f7, #3b82f6, #22c55e);
            border-image-slice: 1;
            border-color: transparent; /* Fallback */
        }
        /* Ensure legendary border width matches base */
        .card.rarity-legendary { border-width: 3px; }
        #next-card-preview.rarity-legendary { border-width: 2px; }
        
        /* --- NEW: Battle Deck Grid Styles --- */
        #battle-deck-grid .deck-slot {
            width: 75px;
            height: 110px;
            background: rgba(0,0,0,0.3);
            border: 2px dashed #60a5fa;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #60a5fa;
            margin: auto;
        }
        #battle-deck-grid .card {
            /* Uses existing .card styles */
            width: 75px;
            height: 110px;
            margin: 0; /* Override margin: auto */
        }
        

        /* --- REMOVED: Dragged Card Visual --- */
        

        /* --- Game Screen (Copied from before) --- */
        #game-screen {
            background: #111;
        }
        #game-arena {
            flex-grow: 1; 
            width: 100%;
            display: block; 
            /* *** –ù–û–í–ê –ó–ú–Ü–ù–ê: –†–æ–±–∏–º–æ –∫—É—Ä—Å–æ—Ä "—Ü—ñ–ª–ª—é" *** */
            cursor: crosshair; 
        }
        #opponent-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            padding: 4px 8px;
            font-size: 14px;
            font-weight: 600;
            color: #f87171; /* Red team */
        }
        #opponent-info .trophies {
            color: #f59e0b;
            font-size: 12px;
        }
        
        #game-ui {
            flex-shrink: 0; 
            background-color: #3a2e2a; 
            padding: 8px;
            border-top: 4px solid #2a1e1a;
            display: flex;
            flex-direction: column;
        }
        
        #hand-container {
            display: flex;
            align-items: center;
            justify-content: center; /* Center the whole group */
            padding: 8px 0;
            order: 1; /* Show before elixir */
        }

        #next-card-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-right: 10px;
        }
        #next-card-label {
            font-size: 12px;
            font-weight: 600;
            color: #ddd;
            margin-bottom: 2px;
        }
        #next-card-preview {
            width: 55px; /* Smaller card */
            height: 80px;
            background: linear-gradient(145deg, #e0e0e0, #c0c0c0);
            border: 2px solid #fff;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 2px;
            position: relative;
            font-weight: bold;
        }
        
        /* --- NEW: SVG Next Card Image Style --- */
        .next-card-image {
            width: 100%;
            height: 40px; /* Adjust height for preview card */
            padding: 2px;
            border-radius: 3px;
            margin-top: 2px;
        }
        .next-card-image svg {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        #next-card-preview .card-cost {
            position: absolute;
            top: -4px;
            left: -4px;
            width: 20px;
            height: 20px;
            font-size: 12px;
            background-color: #a800a8;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid white;
        }
        #next-card-preview .card-name { font-size: 9px; color: #111; text-align: center; }

        #card-hand {
            display: flex;
            justify-content: center;
            align-items: center;
            height: auto; /* Remove fixed height */
            gap: 8px; /* Space cards out */
        }
        .card.disabled {
            filter: grayscale(80%);
            opacity: 0.6;
        }
        .card.selected {
            transform: translateY(-15px) scale(1.1);
            border-color: #facc15;
            box-shadow: 0 0 25px #facc15;
        }
        
        #elixir-container {
            width: 100%;
            margin: 8px auto 0 auto; /* Margin top */
            background: #111;
            border-radius: 10px;
            height: 20px;
            border: 2px solid #c0c0c0;
            overflow: hidden;
            position: relative;
            order: 2; /* Force to bottom */
        }
        #elixir-bar {
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, #d834d8, #a800a8);
            transition: width 0.2s ease;
        }
        #elixir-text {
            position: absolute;
            inset: 0;
            color: white;
            font-weight: bold;
            font-size: 14px;
            text-align: center;
            text-shadow: 1px 1px 2px black;
        }

        #message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            font-size: 3em;
            font-weight: bold;
            color: white;
            text-align: center;
            z-index: 100;
        }
        #message-home-button {
            font-size: 18px;
            padding: 8px 16px;
            margin-top: 15px;
            background: #2563eb;
            border-radius: 8px;
            cursor: pointer;
        }
    </style>
    <!-- 3. Load Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
</head>
<body class="flex items-center justify-center">

    <!-- 4. Main Menu Screen (NEW UI) -->
    <div id="main-menu-screen" class="screen">
        
        <!-- Top Bar (NEW DESIGN based on image_38c741.png) -->
        <div class="menu-top-bar">
            <!-- Left Side: XP -->
            <div class="flex items-center space-x-2">
                <div class="w-10 h-10 bg-blue-500 rounded-lg flex items-center justify-center border-2 border-blue-300 shadow-md">
                    <!-- King Icon SVG -->
                    <svg class="w-8 h-8" fill="#fde047" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v-2h-2v2zm0 4h2v6h-2v-6z"/></svg>
                </div>
                <!-- XP Bar -->
                <div class="bg-blue-800 rounded-lg h-7 flex items-center px-2 relative w-40 border-2 border-blue-400 shadow-md">
                    <div class="absolute left-0 top-0 h-full bg-blue-500 rounded-l-sm" style="width: 47%;"></div> <!-- 35286/75000 is ~47% -->
                    <span class="relative text-sm font-bold z-10 text-white [text-shadow:_1px_1px_1px_rgb(0_0_0_/_100%)]">52</span>
                    <span class="relative text-xs font-bold z-10 ml-auto text-white [text-shadow:_1px_1px_1px_rgb(0_0_0_/_100%)]">35286/75000</span>
                </div>
            </div>

            <!-- Right Side: Currency -->
            <div class="flex items-center space-x-2">
                <!-- ** NEW ID ** -->
                <div id="add-gold-btn" class="w-8 h-8 bg-green-500 rounded-md flex items-center justify-center border-2 border-green-300 shadow-md cursor-pointer">
                    <!-- Plus Icon SVG -->
                    <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm.75-11.25a.75.75 0 00-1.5 0v2.5h-2.5a.75.75 0 000 1.5h2.5v2.5a.75.75 0 001.5 0v-2.5h2.5a.75.75 0 000-1.5h-2.5v-2.5z" clip-rule="evenodd" /></svg>
                </div>
                <div class="flex items-center space-x-1">
                    <!-- ** NEW ID ** -->
                    <span id="gold-display" class="text-lg font-bold text-white [text-shadow:_1px_1px_1px_rgb(0_0_0_/_100%)]">259 928</span>
                    <!-- Gold Coin SVG (filled checkmark style) -->
                    <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="#fbbf24"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-1.12-9.62a.75.75 0 00-1.06 1.06l1.5 1.5a.75.75 0 001.06 0l3-3a.75.75 0 00-1.06-1.06L9.5 11.69l-1.12-1.12z" clip-rule="evenodd" /></svg>
                </div>
                <!-- ** NEW ID ** -->
                 <div id="add-gems-btn" class="w-8 h-8 bg-green-500 rounded-md flex items-center justify-center border-2 border-green-300 shadow-md cursor-pointer">
                    <!-- Plus Icon SVG -->
                    <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm.75-11.25a.75.75 0 00-1.5 0v2.5h-2.5a.75.75 0 000 1.5h2.5v2.5a.75.75 0 001.5 0v-2.5h2.5a.75.75 0 000-1.5h-2.5v-2.5z" clip-rule="evenodd" /></svg>
                </div>
                <div class="flex items-center space-x-1">
                    <!-- ** NEW ID ** -->
                    <span id="gems-display" class="text-lg font-bold text-white [text-shadow:_1px_1px_1px_rgb(0_0_0_/_100%)]">12</span>
                    <!-- Gem SVG -->
                    <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="#22c55e"><path d="M10.828 3.013c.252-.244.62-.244.872 0l4.243 4.13c.252.244.329.619.191.951L12.18 18.068c-.138.332-.5.549-.894.549h-2.572c-.394 0-.756-.217-.894-.549L3.874 8.094a.75.75 0 01.191-.951l4.243-4.13z" fill="#22c55e" /></svg>
                </div>
            </div>
        </div>
        
        <!-- Top Right Buttons -->
        <div class="menu-top-buttons">
            <div class="menu-icon-button">
                <!-- Profile -->
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 6a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0zM4.501 20.118a7.5 7.5 0 0114.998 0A17.933 17.933 0 0112 21.75c-2.676 0-5.216-.584-7.499-1.632z" /></svg>
                <div class="notification-badge">1</div>
            </div>
            <div class="menu-icon-button">
                <!-- Pass Royale -->
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.5 6v.75m0 3v.75m0 3v.75m0 3V18m-9-1.5h5.25m-7.5 0h.008v.008H4.5v-.008zM4.5 9h.008v.008H4.5V9zm.008 3h.008v.008H4.5v-.008zm.008 3h.008v.008H4.5v-.008zM2.25 6h19.5v12H2.25V6z" /></svg>
            </div>
            <div class="menu-icon-button">
                <!-- Menu -->
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" /></svg>
            </div>
        </div>

        <!-- === NEW: Tab Content Area === -->
        
        <!-- Tab 1: Battle (Visible by default) -->
        <div id="tab-content-battle" class="tab-content">
            <!-- Player Banner (v8.1) -->
            <div class="menu-player-banner">
                <div class="name">RoyalkA</div>
                <div class="clan">–ì–†–≠–ú–õ–ò–ù–´ 2.0</div>
                <div class="trophies">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5"><path fill-rule="evenodd" d="M15.19 3.684a.75.75 0 01.44 1.316l-2.006 1.003a.75.75 0 00-.398.53l-1.04 4.161a.75.75 0 00.44 1.316l1.04-1.04a.75.75 0 011.06 0l1.72 1.72a.75.75 0 010 1.06l-1.04 1.04a.75.75 0 001.316.44l4.161-1.04a.75.75 0 00.53-.398l1.003-2.006a.75.75 0 011.316.44l-1.003 4.887a.75.75 0 01-1.316-.44l1.003-2.006a.75.75 0 00-.53-.398l-4.161-1.04a.75.75 0 00-1.316.44l1.04 1.04a.75.75 0 01-1.06 0l-1.72-1.72a.75.75 0 010-1.06l1.04-1.04a.75.75 0 00-.44-1.316l-4.887-1.003a.75.75 0 01-.44-1.316l2.006-1.003a.75.75 0 00.398-.53l-1.04-4.161a.75.75 0 00-1.316-.44l-1.04 1.04a.75.75 0 01-1.06 0l-1.72-1.72a.75.75 0 010-1.06l1.04-1.04a.75.75 0 00.44-1.316L2.34 3.016a.75.75 0 01.44-1.316l2.006 1.003a.75.75 0 00.398.53l1.04 4.161a.75.75 0 001.316.44l1.04-1.04a.75.75 0 011.06 0l1.72 1.72a.75.75 0 010 1.06l-1.04 1.04a.75.75 0 00-.44 1.316l4.887 1.003zM4.75 5.5a.75.75 0 01.75-.75h9a.75.75 0 010 1.5h-9a.75.75 0 01-.75-.75z" clip-rule="evenodd" /></svg>
                    <span>5018</span>
                </div>
            </div>
            
            <div class="menu-arena-art">
                <svg viewBox="0 0 200 150" xmlns="http://www.w3.org/2000/svg">
                    <rect x="0" y="65" width="200" height="20" fill="#1e40af" />
                    <rect x="40" y="60" width="30" height="30" fill="#a16207" />
                    <rect x="130" y="60" width="30" height="30" fill="#a16207" />
                    <rect x="50" y="30" width="20" height="20" fill="#4b5563" />
                    <rect x="130" y="30" width="20" height="20" fill="#4b5563" />
                    <rect x="85" y="10" width="30" height="30" fill="#6b7280" />
                    <rect x="50" y="100" width="20" height="20" fill="#4b5563" />
                    <rect x="130" y="100" width="20" height="20" fill="#4b5563" />
                    <rect x="85" y="110" width="30" height="30" fill="#6b7280" />
                    <path d="M 50 75 L 50 100 M 150 75 L 150 100 M 95 110 L 95 100 L 50 100 M 105 110 L 105 100 L 150 100" stroke="#fde68a" stroke-width="4" fill="none" />
                    <path d="M 50 75 L 50 50 M 150 75 L 150 50 M 95 40 L 95 50 L 50 50 M 105 40 L 105 50 L 150 50" stroke="#fde68a" stroke-width="4" fill="none" />
                </svg>
            </div>
            
            <div id="play-button">Battle</div>
            
            <div class="menu-chest-slots">
                <div class="chest-slot filled">
                    üõ°Ô∏è
                    <span class="text-xs font-bold mt-1">ARENA 1</span>
                </div>
                <div class="chest-slot">Chest Slot</div>
                <div class="chest-slot">Chest Slot</div>
                <div class="chest-slot">Chest Slot</div>
            </div>
        </div>

        <!-- Tab 2: Cards (Hidden by default) -->
        <div id="tab-content-cards" class="tab-content hidden">
            
            <!-- === NEW: Battle Deck Section (Moved to top) === -->
            <div class="w-full max-w-md px-4">
                <!-- Title based on screenshot -->
                <h2 class="text-2xl font-bold text-center mb-2 text-white [text-shadow:_1px_1px_2px_rgb(0_0_0_/_50%)]">Battle Deck</h2>
                <div id="battle-deck-grid" class="grid grid-cols-4 gap-4 bg-blue-900 p-4 rounded-lg border-2 border-blue-400 shadow-lg">
                    <!-- 8 slots populated by JS -->
                </div>
                <div id="battle-deck-stats" class="text-center text-lg font-bold mt-2 text-yellow-400 [text-shadow:_1px_1px_2px_rgb(0_0_0_/_50%)]">
                    <!-- Deck stats populated by JS -->
                </div>
            </div>
            <!-- === END: Battle Deck Section === -->

            <!-- Title based on screenshot -->
            <h2 class="text-2xl font-bold mt-6 text-white [text-shadow:_1px_1px_2px_rgb(0_0_0_/_50%)]">Card Collection</h2>
            <div id="card-collection-info" class="text-sm text-gray-300">
                <!-- Placeholder for filters/count -->
                <!-- MODIFIED: Added id="card-collection-total" -->
                <span>Found: <span id="card-collection-count">0</span> / <span id="card-collection-total">17</span></span>
            </div>

            <div id="card-collection-grid" class="w-full max-w-md grid grid-cols-4 gap-4 px-4 mt-2">
                <!-- Populated by JS, now filters deck cards -->
            </div>
        </div>
        
        <!-- Tab 3: Shop (Placeholder) -->
        <div id="tab-content-shop" class="tab-content hidden p-0"> <!-- Removed padding -->
            <!-- Daily Deals Section -->
            <div class="shop-section">
                <h2 class="shop-section-header">Daily Deals</h2>
                <div class="grid grid-cols-3 gap-3" id="daily-deals-grid">
                    <!-- Populated by JS -->
                </div>
            </div>
        
            <!-- Currency Shop Section -->
            <div class="shop-section">
                <!-- Gems -->
                <h2 class="shop-section-header" style="background-color: #16a34a;">Gems</h2>
                <div class="grid grid-cols-3 gap-3" id="gem-offers-grid">
                    <!-- Populated by JS -->
                </div>
        
                <!-- Gold -->
                <h2 class="shop-section-header" style="background-color: #f59e0b; margin-top: 16px;">Gold</h2>
                <div class="grid grid-cols-3 gap-3" id="gold-offers-grid">
                    <!-- Populated by JS -->
                </div>
            </div>
        </div>
        
        <!-- Tab 4: Clan (Placeholder) -->
        <div id="tab-content-clan" class="tab-content hidden">
            <h2 class="text-2xl font-bold mt-4">Clan</h2>
            <p>(–¢—É—Ç –±—É–¥–µ –∫–ª–∞–Ω)</p>
        </div>
        
        <!-- Tab 5: Events (Placeholder) -->
        <div id="tab-content-events" class="tab-content hidden">
            <h2 class="text-2xl font-bold mt-4">Events</h2>
            <p>(–¢—É—Ç –±—É–¥—É—Ç—å –ø–æ–¥—ñ—ó)</p>
        </div>

        <!-- === NEW: Card Stats Popup (Hidden by default) === -->
        <div id="card-stats-popup" class="hidden items-center justify-center">
            <div class="popup-content">
                <div id="popup-close-btn">&times;</div>
                <div class="popup-header">
                    <!-- Card Preview -->
                    <div id="popup-card-preview" class="card">
                        <!-- Populated by JS -->
                    </div>
                    <!-- Info -->
                    <div class="popup-info">
                        <h2 id="popup-card-name">Card Name</h2>
                        <div class="popup-rarity-bar">
                            <span id="popup-card-rarity">Common</span>
                            <span id="popup-card-type">Troop</span>
                        </div>
                        <p id="popup-card-description">
                            Card description goes here. It's a very good card.
                        </p>
                    </div>
                </div>
                <!-- Stats Grid -->
                <div class="popup-stats-grid">
                    <div class="popup-stat-box" id="stat-hp">
                        <div class="label">‚ù§Ô∏è Hitpoints</div>
                        <div class="value" id="popup-card-hp">600</div>
                    </div>
                    <div class="popup-stat-box" id="stat-damage">
                        <div class="label">‚öîÔ∏è Damage</div>
                        <div class="value" id="popup-card-damage">75</div>
                    </div>
                    <div class="popup-stat-box" id="stat-speed">
                        <div class="label">üèÉ Speed</div>
                        <div class="value" id="popup-card-speed">Medium</div>
                    </div>
                    <div class="popup-stat-box" id="stat-range">
                        <div class="label">üéØ Range</div>
                        <div class="value" id="popup-card-range">1 (Melee)</div>
                    </div>
                    <div class="popup-stat-box" id="stat-attack-speed">
                        <div class="label">‚è±Ô∏è Hit Speed</div>
                        <div class="value" id="popup-card-attack-speed">1.0s</div>
                    </div>
                    <div class="popup-stat-box" id="stat-targets">
                        <div class="label">üéØ Targets</div>
                        <div class="value" id="popup-card-targets">Ground</div>
                    </div>
                    <!-- NEW: Stat box for Lifetime (for buildings) -->
                    <div class="popup-stat-box" id="stat-lifetime">
                        <div class="label">‚è≥ Lifetime</div>
                        <div class="value" id="popup-card-lifetime">30s</div>
                    </div>
                </div>
                
                <!-- === NEW: Deck Button === -->
                <button id="popup-deck-button" class="w-full bg-green-500 text-white font-bold py-2 px-4 rounded-lg mt-4 border-b-4 border-green-700 hover:bg-green-600 transition-all">
                    Add to Deck
                </button>
                <!-- === END: Deck Button === -->

                <!-- === NEW: GEMINI API SECTION === -->
                <div class="mt-4">
                    <button id="gemini-tips-button" class="w-full">
                        ‚ú® –ü–æ—Ä–∞–¥–∏ –≤—ñ–¥ Gemini
                    </button>
                    <div id="gemini-tips-result" class="hidden mt-3 p-3 bg-gray-200 rounded-lg text-sm text-gray-800 border-2 border-gray-400">
                        <!-- Gemini results will be loaded here -->
                    </div>
                </div>
                <!-- === END GEMINI API SECTION === -->

            </div>
        </div>

        
        <!-- Bottom Nav -->
        <div class="menu-bottom-nav">
            <div id="nav-btn-shop" class="menu-nav-button">
                <div class="icon-bg">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 21v-7.5A.75.75 0 0114.25 12h.75c.414 0 .75.336.75.75V21m-4.5 0v-7.5A.75.75 0 0110.5 12h.75c.414 0 .75.336.75.75V21m-4.5 0v-7.5A.75.75 0 016.75 12h.75c.414 0 .75.336.75.75V21m6-13.5h-1.5a.75.75 0 00-.75.75V6a.75.75 0 00.75.75h1.5a.75.75 0 00.75-.75V5.25a.75.75 0 00-.75-.75zM12 9a.75.75 0 00-.75.75V12a.75.75 0 00.75.75h.008a.75.75 0 00.75-.75V9.75a.75.75 0 00-.75-.75H12zM3 9.75A.75.75 0 013.75 9h.008a.75.75 0 01.75.75v.008a.75.75 0 01-.75.75H3.75a.75.75 0 01-.75-.75V9.75zM4.5 12a.75.75 0 00-.75.75v.008c0 .414.336.75.75.75h.008a.75.75 0 00.75-.75V12.75a.75.75 0 00-.75-.75H4.5zM3.75 15a.75.75 0 01.75-.75h.008a.75.75 0 01.75.75v.008a.75.75 0 01-.75.75H3.75a.75.75 0 01-.75-.75v-.008zM4.5 18a.75.75 0 00-.75.75v.008c0 .414.336.75.75.75h.008a.75.75 0 00.75-.75v-.008a.75.75 0 00-.75-.75H4.5zM18 9.75a.75.75 0 01.75-.75h.008a.75.75 0 01.75.75v.008a.75.75 0 01-.75.75h-.008a.75.75 0 01-.75-.75V9.75zM19.5 12a.75.75 0 00-.75.75v.008c0 .414.336.75.75.75h.008a.75.75 0 00.75-.75V12.75a.75.75 0 00-.75-.75h-.008zM18.75 15a.75.75 0 01.75-.75h.008a.75.75 0 01.75.75v.008a.75.75 0 01-.75.75h-.008a.75.75 0 01-.75-.75v-.008zM19.5 18a.75.75 0 00-.75.75v.008c0 .414.336.75.75.75h.008a.75.75 0 00.75-.75v-.008a.75.75 0 00-.75-.75h-.008z" /></svg>
                </div>
                <span>Shop</span>
            </div>
            <div id="nav-btn-cards" class="menu-nav-button"> <!-- Renamed from 'Deck' to 'Cards' -->
                <div class="icon-bg">
                    <!-- Cards -->
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 15.75l-2.489-2.489m0 0a3.375 3.375 0 10-4.773-4.773 3.375 3.375 0 004.774 4.774zM21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                </div>
                <span>Cards</span>
            </div>
            <div id="nav-btn-battle" class="menu-nav-button active"> <!-- Active by default -->
                <div class="icon-bg">
                    <!-- Battle -->
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12.75 3.03v.568c0 .334.148.65.405.864l1.068.89c.442.369.535 1.01.216 1.49l-.51.766a.75.75 0 01-1.178-.14l-.512-.767a.75.75 0 01-.216-1.49l1.068-.89a1.125 1.125 0 00.405-.864v-.568a.75.75 0 01.672-.744C13.818 2.84 15 3.91 15 5.25v1.5c0 .414-.336.75-.75.75h-4.5a.75.75 0 01-.75-.75v-1.5c0-1.34 1.182-2.41 2.828-2.49a.75.75 0 01.672.744z" /><path stroke-linecap="round" stroke-linejoin="round" d="M3 8.25V19.5a.75.75 0 00.75.75h16.5a.75.75 0 00.75-.75V8.25m-18 0V5.625a.75.75 0 01.75-.75h16.5a.75.75 0 01.75.75v2.625m-18 0h18M5.25 14.25h.008v.008H5.25v-.008zm.75 0h.008v.008H6v-.008zm.75 0h.008v.008H6.75v-.008zm.75 0h.008v.008H7.5v-.008zm.75 0h.008v.008H8.25v-.008zm.75 0h.008v.008H9v-.008zm.75 0h.008v.008H9.75v-.008zm.75 0h.008v.008H10.5v-.008zm.75 0h.008v.008H11.25v-.008zm.75 0h.008v.008H12v-.008zm.75 0h.008v.008H12.75v-.008zm.75 0h.008v.008H13.5v-.008zm.75 0h.008v.008H14.25v-.008zm.75 0h.008v.008H15v-.008zm.75 0h.008v.008H15.75v-.008zm.75 0h.008v.008H16.5v-.008zm.75 0h.008v.008H17.25v-.008zm.75 0h.008v.008H18v-.008z" /></svg>
                </div>
                <span>Battle</span>
            </div>
            <div id="nav-btn-clan" class="menu-nav-button">
                <div class="icon-bg">
                    <!-- Clan -->
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                </div>
                <span>Clan</span>
            </div>
            <div id="nav-btn-events" class="menu-nav-button">
                <div class="icon-bg">
                    <!-- Events -->
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M11.48 3.499a.562.562 0 011.04 0l2.125 5.111a.563.563 0 00.475.345l5.518.442c.499.04.701.663.339.986l-4.204 3.602a.563.563 0 00-.182.557l1.285 5.385a.562.562 0 01-.84.61l-4.725-2.885a.563.563 0 00-.586 0L6.982 20.54a.562.562 0 01-.84-.61l1.285-5.386a.562.562 0 00-.182-.557l-4.204-3.602a.563.563 0 01.34-.986l5.518-.442a.563.563 0 00.475-.345L11.48 3.5z" /></svg>
                </div>
                <span>Events</span>
            </div>
        </div>
    </div>

    <!-- 5. Game Screen (Hidden by default) -->
    <div id="game-screen" class="screen hidden">
        <!-- ** NEW: Opponent Info Display ** -->
        <div id="opponent-info" class="hidden">
            <div id="opponent-name"></div>
            <div id="opponent-trophies" class="trophies"></div>
        </div>
        
        <div id="message" class="hidden">
            <span id="message-text"></span>
            <button id="message-home-button">–í –ú–µ–Ω—é</button>
        </div>
        
        <!-- ** REMOVED: Visual for dragged card ** -->
        
        <canvas id="game-arena"></canvas>
        
        <!-- === NEW UI LAYOUT === -->
        <div id="game-ui">
            <!-- 1. Hand Container (Next + Hand) -->
            <div id="hand-container">
                <!-- 1a. Next Card -->
                <div id="next-card-container">
                    <div id="next-card-label">Next:</div>
                    <div id="next-card-preview">
                        <!-- Populated by JS -->
                    </div>
                </div>
                <!-- 1b. Card Hand -->
                <div id="card-hand">
                    <!-- Populated by JS -->
                </div>
            </div>
            
            <!-- 2. Elixir Bar (At the bottom) -->
            <div id="elixir-container">
                <div id="elixir-bar"></div>
                <div id="elixir-text">5 / 10</div>
            </div>
        </div>
        <!-- === END NEW UI LAYOUT === -->

    </div>

    <!-- 6. The Game Engine (JavaScript) -->
    <script>
        // === APP CONTROLLER (Screen Switching) ===
        const mainMenuScreen = document.getElementById('main-menu-screen');
        const gameScreen = document.getElementById('game-screen');
        const playButton = document.getElementById('play-button');
        const messageHomeButton = document.getElementById('message-home-button');
        const opponentInfoEl = document.getElementById('opponent-info');
        const opponentNameEl = document.getElementById('opponent-name');
        const opponentTrophiesEl = document.getElementById('opponent-trophies');
        
        let currentGame = null;

        playButton.addEventListener('click', () => {
            // === NEW FIX: Check if button is disabled ===
            if (playButton.disabled) {
                console.log("Deck is not full, cannot start battle.");
                return; // –ù–µ —Ä–æ–±–∏—Ç–∏ –Ω—ñ—á–æ–≥–æ, —è–∫—â–æ –∫–Ω–æ–ø–∫–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞
            }
            // === END FIX ===
            
            mainMenuScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            resizeCanvas();
            currentGame = new Game(ctx);
            
            opponentNameEl.innerText = currentGame.aiTrainer.name;
            opponentTrophiesEl.innerText = `üèÜ ${currentGame.aiTrainer.trophies}`;
            opponentInfoEl.classList.remove('hidden');
            
            currentGame.start();
        });

        messageHomeButton.addEventListener('click', () => {
            gameScreen.classList.add('hidden');
            mainMenuScreen.classList.remove('hidden');
            message.classList.add('hidden');
            opponentInfoEl.classList.add('hidden'); // Hide opponent info
            if (currentGame) {
                currentGame.stopGame(); 
                currentGame = null;
            }
        });
        
        // --- NEW: Tab Switching Logic ---
        const tabContents = {
            battle: document.getElementById('tab-content-battle'),
            cards: document.getElementById('tab-content-cards'),
            shop: document.getElementById('tab-content-shop'),
            clan: document.getElementById('tab-content-clan'),
            events: document.getElementById('tab-content-events')
        };
        const navButtons = {
            battle: document.getElementById('nav-btn-battle'),
            cards: document.getElementById('nav-btn-cards'),
            shop: document.getElementById('nav-btn-shop'),
            clan: document.getElementById('nav-btn-clan'),
            events: document.getElementById('nav-btn-events')
        };

        function switchTab(tabName) {
            // 1. Hide all tab content
            Object.values(tabContents).forEach(tab => tab.classList.add('hidden'));
            // 2. Deactivate all nav buttons
            Object.values(navButtons).forEach(btn => btn.classList.remove('active'));
            
            // 3. Show the selected tab content
            if (tabContents[tabName]) {
                tabContents[tabName].classList.remove('hidden');
            }
            // 4. Activate the selected nav button
            if (navButtons[tabName]) {
                navButtons[tabName].classList.add('active');
            }
        }
        
        // Attach click listeners to nav buttons
        navButtons.battle.addEventListener('click', () => switchTab('battle'));
        navButtons.cards.addEventListener('click', () => switchTab('cards'));
        navButtons.shop.addEventListener('click', () => switchTab('shop'));
        navButtons.clan.addEventListener('click', () => switchTab('clan'));
        navButtons.events.addEventListener('click', () => switchTab('events'));

        // === NEW: Add listeners for '+' buttons ===
        document.getElementById('add-gold-btn').addEventListener('click', () => switchTab('shop'));
        document.getElementById('add-gems-btn').addEventListener('click', () => switchTab('shop'));

        
        // === SYNTAX ERROR FIX ===
        // The broken code block from 7.8 is replaced with the correct one.
        document.querySelectorAll('.menu-top-buttons, .menu-top-left, .menu-chest-slots').forEach(btn => {
            if (btn.id !== 'play-button') {
                btn.addEventListener('click', () => {
                    console.log("–¶—è –∫–Ω–æ–ø–∫–∞ –ø–æ–∫–∏ —â–æ –∫–æ—Å–º–µ—Ç–∏—á–Ω–∞!");
                });
            }
        });
        // === END FIX ===


        // === GAME ENGINE CORE ===
        const canvas = document.getElementById('game-arena');
        const ctx = canvas.getContext('2d');
        const elixirBar = document.getElementById('elixir-bar');
        const elixirText = document.getElementById('elixir-text');
        const cardHandContainer = document.getElementById('card-hand');
        const nextCardPreview = document.getElementById('next-card-preview'); 
        const message = document.getElementById('message');
        const messageText = document.getElementById('message-text');
        // === NEW: Battle Deck UI Elements ===
        const battleDeckGrid = document.getElementById('battle-deck-grid');
        const battleDeckStats = document.getElementById('battle-deck-stats');

        // === NEW: Global Currency State ===
        let userGold = 259928;
        let userGems = 12;
        const goldDisplay = document.getElementById('gold-display');
        const gemsDisplay = document.getElementById('gems-display');
        
        function updateTopBarUI() {
            // Formats number with spaces, e.g., 259928 -> "259 928"
            goldDisplay.innerText = userGold.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
            gemsDisplay.innerText = userGems;
        }
        updateTopBarUI(); // Call on initial load
        // === END NEW ===

        // === NEW: GEMINI API Integration ===
        const API_KEY = ""; // Per instructions, leave empty
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
        const geminiTipsButton = document.getElementById('gemini-tips-button');
        const geminiTipsResult = document.getElementById('gemini-tips-result');

        geminiTipsButton.addEventListener('click', handleGeminiTipsClick);

        async function handleGeminiTipsClick() {
            const cardKey = cardStatsPopup.dataset.cardKey;
            if (!cardKey) return;
            
            const cardName = CARD_DECK[cardKey].name;
            
            geminiTipsButton.disabled = true;
            geminiTipsButton.innerText = '–ì–µ–Ω–µ—Ä–∞—Ü—ñ—è... ‚ú®';
            geminiTipsResult.classList.remove('hidden');
            geminiTipsResult.innerHTML = '–î—É–º–∞—é...';

            const systemPrompt = "You are a world-class Clash Royale e-sports coach. Provide two brief, expert tips for the requested card. Use bullet points. Respond in Ukrainian. Do not use markdown like **.";
            const userQuery = `–î–∞–π –º–µ–Ω—ñ –¥–≤—ñ –∫–æ—Ä–æ—Ç–∫—ñ –ø–æ—Ä–∞–¥–∏ –¥–ª—è –∫–∞—Ä—Ç–∏: ${cardName}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
            };

            let response;
            let retries = 3;
            let delay = 1000;
            let success = false;

            while (retries > 0) {
                try {
                    response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        success = true;
                        break; // Success
                    } else if (response.status === 429 || response.status >= 500) {
                        // Throttling or server error, wait and retry
                        console.log(`Gemini API error ${response.status}, retrying in ${delay}ms...`);
                        await new Promise(res => setTimeout(res, delay));
                        delay *= 2; // Exponential backoff
                        retries--;
                    } else {
                        // Other client-side error (e.g., 400), don't retry
                        throw new Error(`Gemini API request failed with status ${response.status}`);
                    }
                } catch (error) {
                    console.error("Fetch error:", error);
                    // Network error, retry
                    await new Promise(res => setTimeout(res, delay));
                    delay *= 2;
                    retries--;
                }
            }

            if (success) {
                try {
                    const result = await response.json();
                    const text = result.candidates[0].content.parts[0].text;
                    
                    // Format bullet points for HTML
                    const htmlText = '<ul>' + text.split('\n')
                        .map(line => line.trim())
                        .filter(line => line.length > 0)
                        .map(line => `<li>${line.replace(/^[‚Ä¢*-\s]+/, '')}</li>`)
                        .join('') + '</ul>';
                        
                    geminiTipsResult.innerHTML = htmlText;
                } catch (parseError) {
                    console.error("Gemini response parse error:", parseError);
                    geminiTipsResult.innerText = '–ü–æ–º–∏–ª–∫–∞: –Ω–µ –≤–¥–∞–ª–æ—Å—è –æ–±—Ä–æ–±–∏—Ç–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥—å.';
                }
            } else {
                geminiTipsResult.innerText = '–ü–æ–º–∏–ª–∫–∞: –Ω–µ –≤–¥–∞–ª–æ—Å—è –∑–≤\'—è–∑–∞—Ç–∏—Å—è –∑ API Gemini.';
            }

            geminiTipsButton.disabled = false;
            geminiTipsButton.innerText = '‚ú® –ü–æ—Ä–∞–¥–∏ –≤—ñ–¥ Gemini';
        }
        // === END GEMINI API ===


        let canvasRect;
        function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            canvasRect = canvas.getBoundingClientRect();
        }
        window.addEventListener('resize', () => {
            if (!gameScreen.classList.contains('hidden')) {
                resizeCanvas();
            }
        });
        
        const ELIXIR_MAX = 10;
        const ELIXIR_REGEN_RATE = 1.0; 
        const GAME_STATE = {
            RUNNING: 'RUNNING',
            PLAYER_WINS: 'PLAYER_WINS',
            AI_WINS: 'AI_WINS'
        };
        
        // === NEW: SVG Graphics Library (17 Cards) ===
        const CARD_SVG_GRAPHICS = {
            'knight': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g fill="#94a3b8"><path d="M20 30 L50 10 L80 30 L80 60 L50 90 L20 60 Z" /><path d="M50 10 L50 90" stroke="#f8fafc" stroke-width="4" /></g><rect x="45" y="70" width="10" height="25" fill="#a16207" /><path d="M35 80 L65 80 L50 70 Z" fill="#e2e8f0" /></svg>`,
            'archers': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M60 10 C 80 30, 80 70, 60 90" stroke="#a16207" stroke-width="6" fill="none" /><path d="M62 10 L62 90" stroke="#fefce8" stroke-width="2" fill="none" /><path d="M60 50 L20 50 L30 45 M20 50 L30 55" stroke="#f59e0b" stroke-width="5" fill="none" /><path d="M25 40 L25 60" stroke="#a16207" stroke-width="5" fill="none" /></svg>`,
            'giant': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><rect x="10" y="10" width="80" height="80" rx="20" fill="#fca5a5" /><rect x="25" y="30" width="20" height="20" fill="#1e293b" rx="5"/><rect x="55" y="30" width="20" height="20" fill="#1e293b" rx="5"/><rect x="20" y="60" width="60" height="15" fill="#9f1239" rx="5"/><rect x="25" y="60" width="10" height="15" fill="#fef08a"/><rect x="65" y="60" width="10" height="15" fill="#fef08a"/></svg>`,
            'wizard': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M50 10 L20 90 L80 90 Z" fill="#3b0764" /><path d="M25 80 L75 80" stroke="#facc15" stroke-width="5" /><circle cx="50" cy="50" r="10" fill="#fef08a" /><path d="M50 50 l-10 -10 m 10 10 l 10 -10 m -10 10 l -10 10 m 10 -10 l 10 10" stroke="#f59e0b" stroke-width="4" /></svg>`,
            'goblins': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M50 10 C 80 10, 90 40, 90 60 C 90 90, 10 90, 10 60 C 10 40, 20 10, 50 10 Z" fill="#16a34a" /><path d="M20 40 L10 20 L30 30 Z" fill="#14532d" /><path d="M80 40 L90 20 L70 30 Z" fill="#14532d" /><circle cx="35" cy="45" r="10" fill="#fef08a" /><circle cx="65" cy="45" r="10" fill="#fef08a" /><rect x="30" y="70" width="40" height="10" rx="5" fill="#1e293b" /></svg>`,
            'miniPekka': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M20 30 L50 10 L80 30 L80 70 L50 90 L20 70 Z" fill="#475569" /><path d="M10 35 L30 20" stroke="#f59e0b" stroke-width="8" /><path d="M90 35 L70 20" stroke="#f59e0b" stroke-width="8" /><rect x="35" y="40" width="30" height="20" fill="#3b82f6" rx="5" /><path d="M60 70 L90 60 L90 80 Z" fill="#94a3b8" /><path d="M70 75 L100 70 L100 90 Z" fill="#e2e8f0" /></svg>`,
            'lavaHound': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M20 70 C 10 50, 40 20, 50 20 C 60 20, 90 50, 80 70 C 90 90, 10 90, 20 70 Z" fill="#7f1d1d" /><circle cx="50" cy="60" r="10" fill="#b91c1c" /><circle cx="35" cy="75" r="5" fill="#b91c1c" /><circle cx="65" cy="75" r="5" fill="#b91c1c" /></svg>`,
            'archerQueen': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M20 80 L 30 30 L 50 50 L 70 30 L 80 80 L 20 80 Z" fill="#facc15" stroke="#b45309" stroke-width="4" /><circle cx="30" cy="30" r="8" fill="#fde047" /><circle cx="50" cy="50" r="8" fill="#fde047" /><circle cx="70" cy="30" r="8" fill="#fde047" /></svg>`,
            'musketeer': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><rect x="40" y="30" width="20" height="50" fill="#7f1d1d" /><path d="M30 10 L 70 10 L 80 30 L 20 30 Z" fill="#b91c1c" /><rect x="55" y="40" width="30" height="10" fill="#1e293b" /></svg>`,
            'valkyrie': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g fill="#e2e8f0" stroke="#f59e0b" stroke-width="4"><path d="M50 10 L 90 50 L 50 90 L 10 50 Z" /><path d="M30 30 L 70 70 M 70 30 L 30 70" stroke-width="6" /></g><rect x="45" y="70" width="10" height="25" fill="#a16207" /></svg>`,
            'hogRider': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M20 50 L 80 50 L 80 80 L 60 80 L 60 60 L 40 60 L 40 80 L 20 80 Z" fill="#475569" /><rect x="35" y="20" width="30" height="30" fill="#a16207" /></svg>`,
            'skeletonArmy': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="40" r="15" fill="#e2e8f0" /><rect x="45" y="55" width="10" height="30" fill="#e2e8f0" /><path d="M30 50 L 70 50 M 40 65 L 60 65" stroke="#e2e8f0" stroke-width="4" /></svg>`,
            'minions': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M50 20 C 30 30, 20 50, 30 70 L 70 70 C 80 50, 70 30, 50 20 Z" fill="#1e3a8a" /><path d="M20 40 L 30 60 L 10 50 Z" fill="#3b82f6" /><path d="M80 40 L 70 60 L 90 50 Z" fill="#3b82f6" /></svg>`,
            'fireball': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><defs><radialGradient id="gradFB" cx="0.5" cy="0.5" r="0.5"><stop offset="0%" stop-color="#fef08a" /><stop offset="50%" stop-color="#f59e0b" /><stop offset="90%" stop-color="#b45309" /><stop offset="100%" stop-color="transparent" /></radialGradient></defs><circle cx="50" cy="50" r="40" fill="url(#gradFB)" /><path d="M50 10 C 30 30, 70 50, 50 50" fill="#fef08a" /><path d="M60 20 C 40 40, 80 60, 60 60" fill="#fde68a" /><path d="M40 70 C 60 50, 20 90, 40 70" fill="#fcd34d" /></svg>`,
            'arrows': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g transform="rotate(-45 50 50)"><path d="M50 10 L50 70 L45 65 M 50 70 L 55 65" stroke="#f59e0b" stroke-width="6" fill="none" /><path d="M45 20 L45 80 L40 75 M 45 80 L 50 75" stroke="#f59e0b" stroke-width="6" fill="none" /><path d="M55 20 L55 80 L50 75 M 55 80 L 60 75" stroke="#f59e0b" stroke-width="6" fill="none" /></g></svg>`,
            'zap': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M50 10 L 30 50 L 45 50 L 35 90 L 70 40 L 55 40 Z" fill="#facc15" stroke="#f59e0b" stroke-width="4" /></svg>`,
            'cannon': `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><rect x="20" y="40" width="60" height="40" rx="10" fill="#4b5563" /><rect x="30" y="10" width="20" height="40" fill="#1e293b" /><circle cx="70" cy="60" r="15" fill="#1e293b" /><circle cx="30" cy="60" r="15" fill="#1e293b" /></svg>`,
        };

        // ** NEW: Card Deck from user's latest table (17 Cards) **
        const CARD_DECK = {
            'knight':    { 
                name: 'Knight', emoji: 'üõ°Ô∏è', cost: 3, type: 'unit',
                rarity: 'Common', targets: 'Ground',
                stats: { hp: 1766, damage: 202, attackSpeed: 1/1.2, range: 1.2, speed: 'Medium' },
                description: 'A tough melee fighter. Not tiny, not giant, just right.'
            },
            'archers':   { 
                name: 'Archers', emoji: 'üèπ', cost: 3, type: 'unit',
                rarity: 'Common', targets: 'Air & Ground',
                stats: { hp: 304, damage: 112, attackSpeed: 1/0.9, range: 5, speed: 'Medium' },
                description: 'A pair of lightly-armored ranged attackers. They help cover the sky.'
            },
            'giant':     { 
                name: 'Giant', emoji: 'üëπ', cost: 5, type: 'unit',
                rarity: 'Rare', targets: 'Buildings',
                stats: { hp: 4090, damage: 253, attackSpeed: 1/1.5, range: 1.2, speed: 'Slow' },
                description: 'Slow but durable, only attacks buildings. A real wrecking ball!'
            },
            'wizard':    { 
                name: 'Wizard', emoji: 'üßô', cost: 5, type: 'unit',
                rarity: 'Rare', targets: 'Air & Ground',
                stats: { hp: 755, damage: 281, attackSpeed: 1/1.4, range: 5.5, speed: 'Medium' },
                description: 'The most wonderful unit in the arena, casting powerful area damage spells.'
            },
            'goblins':    { 
                name: 'Goblins', emoji: 'üü¢', cost: 2, type: 'unit',
                rarity: 'Common', targets: 'Ground',
                stats: { hp: 202, damage: 120, attackSpeed: 1/1.1, range: 0.5, speed: 'Very Fast' },
                description: 'Four fast, melee attackers. Small, fast, green, and mean!'
            },
            'miniPekka': { 
                name: 'Mini P.E.K.K.A.', emoji: 'ü§ñ', cost: 4, type: 'unit',
                rarity: 'Rare', targets: 'Ground',
                stats: { hp: 1433, damage: 755, attackSpeed: 1/1.6, range: 0.8, speed: 'Medium' },
                description: 'Pancakes! Loves to destroy anything in its path with its mighty sword.'
            },
            'lavaHound': { 
                name: 'Lava Hound', emoji: 'üî•', cost: 7, type: 'unit',
                rarity: 'Legendary', targets: 'Buildings',
                stats: { hp: 3581, damage: 53, attackSpeed: 1/1.3, range: 3.5, speed: 'Slow' },
                description: 'The Lava Hound is a majestic flying beast that attacks buildings.'
            },
            'archerQueen': { 
                name: 'Archer Queen', emoji: 'üëë', cost: 5, type: 'unit',
                rarity: 'Champion', targets: 'Air & Ground',
                stats: { hp: 1000, damage: 225, attackSpeed: 1/1.2, range: 5, speed: 'Medium' },
                description: 'A fierce warrior who attacks from a distance.'
            },
            'musketeer': { 
                name: 'Musketeer', emoji: 'üéØ', cost: 4, type: 'unit',
                rarity: 'Rare', targets: 'Air & Ground',
                stats: { hp: 721, damage: 217, attackSpeed: 1/1.0, range: 6, speed: 'Medium' },
                description: 'Don\'t be fooled by her delicately coiffed hair; the Musketeer is a mean shot.'
            },
            'valkyrie':  { 
                name: 'Valkyrie', emoji: 'ü™ì', cost: 4, type: 'unit',
                rarity: 'Rare', targets: 'Ground',
                stats: { hp: 1907, damage: 266, attackSpeed: 1/1.5, range: 1.2, speed: 'Medium' },
                description: 'Tough melee fighter, deals area damage around her.'
            },
            'hogRider':  { 
                name: 'Hog Rider', emoji: 'üî®', cost: 4, type: 'unit',
                rarity: 'Rare', targets: 'Buildings',
                stats: { hp: 1697, damage: 317, attackSpeed: 1/1.6, range: 0.8, speed: 'Very Fast' },
                description: 'Fast melee troop that targets buildings.'
            },
            'skeletonArmy': { 
                name: 'Skeleton Army', emoji: 'üíÄ', cost: 3, type: 'unit',
                rarity: 'Epic', targets: 'Ground',
                stats: { hp: 81, damage: 81, attackSpeed: 1/1.1, range: 0.5, speed: 'Medium' },
                description: 'Spawns an army of Skeletons. Meet Larry and his friends.'
            },
            'minions': { 
                name: 'Minions', emoji: 'ü¶á', cost: 3, type: 'unit',
                rarity: 'Common', targets: 'Air & Ground',
                stats: { hp: 230, damage: 107, attackSpeed: 1/1.1, range: 2.5, speed: 'Fast' },
                description: 'Three fast, unarmored flying attackers.'
            },
            'fireball':  { 
                name: 'Fireball', emoji: 'üî•', cost: 4, type: 'spell',
                rarity: 'Rare', targets: 'Air & Ground',
                stats: { damage: 688, range: 2.5 }, 
                description: 'Annnnnd... Fireball. Incinerates a small area.'
            },
            'arrows':    { 
                name: 'Arrows', emoji: 'üéØ', cost: 3, type: 'spell',
                rarity: 'Common', targets: 'Air & Ground',
                stats: { damage: 366, range: 3.5 }, // From table
                description: 'Rains arrows over a large area. Good for clearing swarms.'
            },
            'zap':       { 
                name: 'Zap', emoji: '‚ö°', cost: 2, type: 'spell',
                rarity: 'Common', targets: 'Air & Ground',
                stats: { damage: 192, range: 2.5 },
                description: 'Zaps enemies, briefly stunning them.'
            },
            'cannon':    { 
                name: 'Cannon', emoji: 'üí£', cost: 3, type: 'building',
                rarity: 'Common', targets: 'Ground',
                stats: { hp: 824, damage: 212, attackSpeed: 1/1.0, range: 5.5, lifetime: 30 },
                description: 'Defensive building. Shoots cannonballs at ground troops.'
            }
        };
        const FULL_DECK_KEYS = Object.keys(CARD_DECK);
        
        // === NEW: Global Player Battle Deck ===
        let playerBattleDeck = FULL_DECK_KEYS.slice(0, 8); // Default 8-card deck

        const TRAINER_LIST = [
            { name: "Trainer Earl", trophies: 1200 }, { name: "Trainer Fikova", trophies: 1350 },
            { name: "Trainer Mike", trophies: 1100 }, { name: "Trainer Klaus", trophies: 1400 },
            { name: "Trainer Teemu", trophies: 1250 }, { name: "Trainer Jonas", trophies: 1300 },
            { name: "Trainer George", trophies: 1150 }, { name: "Trainer James", trophies: 1450 },
            { name: "Trainer Cheese", trophies: 1050 }, { name: "Trainer Urho", trophies: 1200 },
            { name: "Trainer Paul", trophies: 1300 }, { name: "Trainer Gary", trophies: 1250 },
            { name: "Trainer Red", trophies: 1400 }, { name: "Trainer Oak", trophies: 1150 },
            { name: "Trainer Brock", trophies: 1350 }, { name: "Trainer Clemont", trophies: 1100 },
            { name: "Trainer Grumpy", trophies: 1250 }, { name: "Trainer Rush", trophies: 1300 },
            { name: "Trainer Clint", trophies: 1400 }, { name: "Trainer Basil", trophies: 1150 },
            { name: "Trainer Sybil", trophies: 1350 }, { name: "Trainer Dopey", trophies: 1100 },
            { name: "Trainer Marty", trophies: 1250 }, { name: "Trainer Arnold", trophies: 1450 },
            { name: "Trainer Bashful", trophies: 1150 }, { name: "Trainer Dent", trophies: 1300 },
            { name: "Trainer Marvin", trophies: 1250 }, { name: "Trainer Sneezy", trophies: 1350 },
            { name: "Trainer Whisker", trophies: 1100 }, { name: "Trainer Snow", trophies: 1250 },
            { name: "Trainer Sleepy", trophies: 1300 }, { name: "Trainer Freeze", trophies: 1150 },
            { name: "Trainer Jason", trophies: 1250 }, { name: "Trainer Faker", trophies: 1350 },
            { name: "Trainer L√©on", trophies: 1100 }, { name: "Trainer Happy", trophies: 1250 },
            { name: "Trainer Louis", trophies: 1300 }, { name: "Trainer Quincy", trophies: 1150 },
            { name: "Trainer Max", trophies: 1250 }, { name: "Trainer Titan", trophies: 1350 },
            { name: "Trainer Barry", trophies: 1100 }, { name: "Trainer Rocket", trophies: 1250 },
            { name: "Trainer Swiss", trophies: 1300 }, { name: "Trainer Gravy", trophies: 1150 },
            { name: "Trainer Shelly", trophies: 1250 }, { name: "Trainer Dragon", trophies: 1350 },
            { name: "Trainer Gum", trophies: 1100 }, { name: "Trainer Osteri", trophies: 1250 },
            { name: "Trainer Diamond", trophies: 1300 }, { name: "Trainer Cheddar", trophies: 1150 },
            { name: "Trainer Cheddar II", trophies: 1250 }
        ];
        
        // --- NEW: Battle Deck UI Function ---
        function updateBattleDeckUI() {
            battleDeckGrid.innerHTML = '';
            let totalElixir = 0;
            
            // Draw filled slots
            playerBattleDeck.forEach(cardKey => {
                const card = CARD_DECK[cardKey];
                totalElixir += card.cost;
                const cardEl = document.createElement('div');
                cardEl.className = `card rarity-${card.rarity.toLowerCase()}`;
                cardEl.innerHTML = `
                    <div class="card-cost">${card.cost}</div>
                    <div class="card-image">${CARD_SVG_GRAPHICS[cardKey] || ''}</div>
                    <div class="card-name">${card.name}</div>
                `;
                // Add click listener to show stats (and allow removal)
                cardEl.addEventListener('click', () => showCardStats(cardKey));
                battleDeckGrid.appendChild(cardEl);
            });

            // Draw empty slots
            const emptySlots = 8 - playerBattleDeck.length;
            for (let i = 0; i < emptySlots; i++) {
                const slotEl = document.createElement('div');
                slotEl.className = 'deck-slot';
                slotEl.innerText = 'Empty Slot';
                battleDeckGrid.appendChild(slotEl);
            }
            
            // Update stats
            const avgElixir = (playerBattleDeck.length > 0) ? (totalElixir / playerBattleDeck.length).toFixed(1) : 0;
            battleDeckStats.innerText = `Deck: ${playerBattleDeck.length}/8 | Avg. Elixir: ${avgElixir}`;
            
            // === NEW LOGIC FOR DISABLING BATTLE BUTTON ===
            const isDeckFull = playerBattleDeck.length === 8;
            if (isDeckFull) {
                playButton.disabled = false;
                playButton.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                playButton.disabled = true;
                playButton.classList.add('opacity-50', 'cursor-not-allowed');
            }
            // === END NEW LOGIC ===
        }

        // --- NEW: Card Stats Popup Logic ---
        const cardStatsPopup = document.getElementById('card-stats-popup');
        const popupCloseBtn = document.getElementById('popup-close-btn');
        const popupCardPreview = document.getElementById('popup-card-preview');
        const popupCardName = document.getElementById('popup-card-name');
        const popupCardRarity = document.getElementById('popup-card-rarity');
        const popupCardType = document.getElementById('popup-card-type');
        const popupCardDescription = document.getElementById('popup-card-description');
        
        // Stat boxes
        const statBoxHp = document.getElementById('stat-hp');
        const statBoxDamage = document.getElementById('stat-damage');
        const statBoxSpeed = document.getElementById('stat-speed');
        const statBoxRange = document.getElementById('stat-range');
        const statBoxAttackSpeed = document.getElementById('stat-attack-speed');
        const statBoxTargets = document.getElementById('stat-targets');
        const statBoxLifetime = document.getElementById('stat-lifetime'); // NEW
        
        // Stat values
        const popupCardHp = document.getElementById('popup-card-hp');
        const popupCardDamage = document.getElementById('popup-card-damage');
        const popupCardSpeed = document.getElementById('popup-card-speed');
        const popupCardRange = document.getElementById('popup-card-range');
        const popupCardAttackSpeed = document.getElementById('popup-card-attack-speed');
        const popupCardTargets = document.getElementById('popup-card-targets');
        const popupCardLifetime = document.getElementById('popup-card-lifetime'); // NEW

        function showCardStats(cardKey) {
            const card = CARD_DECK[cardKey];
            if (!card) return;

            // ** NEW: Store cardKey for Gemini **
            cardStatsPopup.dataset.cardKey = cardKey;
            
            // 1. Fill Header
            // ** NEW: Add rarity class to popup card **
            popupCardPreview.className = `card rarity-${card.rarity.toLowerCase()}`;
            popupCardPreview.innerHTML = `
                <div class="card-cost">${card.cost}</div>
                <div class="card-image">${CARD_SVG_GRAPHICS[cardKey] || ''}</div>
                <div class="card-name">${card.name}</div>
            `;
            popupCardName.innerText = card.name;
            popupCardRarity.innerText = card.rarity;
            popupCardType.innerText = card.type;
            popupCardDescription.innerText = card.description;

            // 2. Fill Stats Grid (and hide/show boxes)
            const stats = card.stats;
            if (stats.hp) {
                popupCardHp.innerText = stats.hp;
                statBoxHp.classList.remove('hidden');
            } else {
                statBoxHp.classList.add('hidden');
            }
            
            if (stats.damage) {
                popupCardDamage.innerText = stats.damage;
                statBoxDamage.classList.remove('hidden');
            } else {
                statBoxDamage.classList.add('hidden');
            }

            if (stats.speed) {
                popupCardSpeed.innerText = stats.speed;
                statBoxSpeed.classList.remove('hidden');
            } else {
                statBoxSpeed.classList.add('hidden');
            }

            if (stats.range) {
                let rangeText = stats.range;
                if (card.type === 'unit' && stats.range <= 1.5) rangeText += ' (Melee)';
                else if (card.type === 'unit') rangeText += ''; // Just the number
                else if (card.type === 'spell' || card.type === 'building') rangeText += '';
                
                popupCardRange.innerText = rangeText;
                statBoxRange.classList.remove('hidden');
            } else {
                statBoxRange.classList.add('hidden');
            }

            if (stats.attackSpeed) {
                popupCardAttackSpeed.innerText = (1 / stats.attackSpeed).toFixed(1) + 's';
                statBoxAttackSpeed.classList.remove('hidden');
            } else {
                statBoxAttackSpeed.classList.add('hidden');
            }
            
            if (card.targets) {
                popupCardTargets.innerText = card.targets;
                statBoxTargets.classList.remove('hidden');
            } else {
                statBoxTargets.classList.add('hidden');
            }
            
            // NEW: Show Lifetime
            if (stats.lifetime) {
                popupCardLifetime.innerText = stats.lifetime + 's';
                statBoxLifetime.classList.remove('hidden');
            } else {
                statBoxLifetime.classList.add('hidden');
            }
            
            // === NEW: Deck Button Logic ===
            const deckButton = document.getElementById('popup-deck-button'); // Get button
            const isInDeck = playerBattleDeck.includes(cardKey);
            const isDeckFull = playerBattleDeck.length >= 8;

            if (isInDeck) {
                deckButton.innerText = 'Remove from Deck';
                deckButton.className = 'w-full text-white font-bold py-2 px-4 rounded-lg mt-4 border-b-4 transition-all remove'; // Red style
                deckButton.disabled = false;
                
                deckButton.onclick = () => {
                    playerBattleDeck = playerBattleDeck.filter(key => key !== cardKey);
                    hideCardStats(); // –°–ø–µ—Ä—à—É —Ö–æ–≤–∞—î–º–æ –≤—ñ–∫–Ω–æ
                    renderCardScreen(); // –ü–æ—Ç—ñ–º –æ–Ω–æ–≤–ª—é—î–º–æ –û–ë–ò–î–í–ê —Å–ø–∏—Å–∫–∏
                };
                
            } else if (!isInDeck && !isDeckFull) {
                deckButton.innerText = 'Add to Deck';
                deckButton.className = 'w-full bg-green-500 text-white font-bold py-2 px-4 rounded-lg mt-4 border-b-4 border-green-700 hover:bg-green-600 transition-all'; // Green style
                deckButton.disabled = false;
                
                deckButton.onclick = () => {
                    playerBattleDeck.push(cardKey);
                    hideCardStats(); // –°–ø–µ—Ä—à—É —Ö–æ–≤–∞—î–º–æ –≤—ñ–∫–Ω–æ
                    renderCardScreen(); // –ü–æ—Ç—ñ–º –æ–Ω–æ–≤–ª—é—î–º–æ –û–ë–ò–î–í–ê —Å–ø–∏—Å–∫–∏
                };
                
            } else { // !isInDeck && isDeckFull
                deckButton.innerText = 'Deck Full';
                deckButton.className = 'w-full bg-gray-400 text-white font-bold py-2 px-4 rounded-lg mt-4 border-b-4 border-gray-600 transition-all'; // Gray style
                deckButton.disabled = true;
                deckButton.onclick = null;
            }
            // === END: Deck Button Logic ===


            // 3. Reset Gemini Section
            geminiTipsButton.disabled = false;
            geminiTipsButton.innerText = '‚ú® –ü–æ—Ä–∞–¥–∏ –≤—ñ–¥ Gemini';
            geminiTipsResult.classList.add('hidden');
            geminiTipsResult.innerHTML = '';

            // 4. Show Popup (BUG FIX)
            cardStatsPopup.classList.remove('hidden');
            cardStatsPopup.classList.add('flex'); // Add flex display properties
        }

        function hideCardStats() {
            cardStatsPopup.classList.add('hidden');
            cardStatsPopup.classList.remove('flex'); // Remove flex display properties
        }
        
        popupCloseBtn.addEventListener('click', hideCardStats);

        // --- NEW: Populate Card Collection Tab ---
        const cardCollectionGrid = document.getElementById('card-collection-grid');
        const cardCollectionCount = document.getElementById('card-collection-count'); // NEW element
        const cardCollectionTotal = document.getElementById('card-collection-total'); // NEW TOTAL element

        // RENAMED and RE-WRITTEN
        function renderCardCollectionUI() {
            cardCollectionGrid.innerHTML = ''; // Clear it
            let collectionCount = 0; // NEW: Count cards
            
            const totalCardsOwned = FULL_DECK_KEYS.length; // Get total
            
            for (const cardKey in CARD_DECK) {
                // === THE NEW LOGIC ===
                // –Ø–∫—â–æ –∫–∞—Ä—Ç–∞ –í–ñ–ï –≤ –∫–æ–ª–æ–¥—ñ, –ø—Ä–æ–ø—É—Å—Ç–∏—Ç–∏ —ó—ó
                if (playerBattleDeck.includes(cardKey)) {
                    continue; 
                }
                // === END NEW LOGIC ===

                collectionCount++; // –†–∞—Ö—É—î–º–æ –∫–∞—Ä—Ç—É
                const card = CARD_DECK[cardKey];
                const cardEl = document.createElement('div');
                cardEl.className = `card rarity-${card.rarity.toLowerCase()}`; // Reuse and add rarity
                cardEl.innerHTML = `
                    <div class="card-cost">${card.cost}</div>
                    <div class="card-image">${CARD_SVG_GRAPHICS[cardKey] || ''}</div>
                    <div class="card-name">${card.name}</div>
                `;
                // **NEW: Add click listener**
                cardEl.addEventListener('click', () => showCardStats(cardKey));
                cardCollectionGrid.appendChild(cardEl);
            }
            // cardCollectionCount.innerText = collectionCount; // OLD
            cardCollectionCount.innerText = totalCardsOwned; // NEW: Show total owned
            cardCollectionTotal.innerText = totalCardsOwned; // NEW: Update total
        }
        
        // === NEW: Master Render Function ===
        function renderCardScreen() {
            updateBattleDeckUI();     // –û–Ω–æ–≤–ª—é—î –≤–µ—Ä—Ö–Ω—é –∫–æ–ª–æ–¥—É
            renderCardCollectionUI(); // –û–Ω–æ–≤–ª—é—î –Ω–∏–∂–Ω—é –∫–æ–ª–µ–∫—Ü—ñ—é (–∑ —Ñ—ñ–ª—å—Ç—Ä–∞—Ü—ñ—î—é)
        }

        // === NEW: Shop Definition ===
        const SHOP_OFFERS = {
            // ** RANDOMIZED: daily: [], **
            gems: [
                { type: 'gems', name: 'Pouch of Gems', amount: 500, price: 79.99, currency: 'uah', imageUrl: 'https://placehold.co/100x80/22c55e/ffffff?text=500+Gems' },
                { type: 'gems', name: 'Bucket of Gems', amount: 1200, price: 199.99, currency: 'uah', imageUrl: 'https://placehold.co/100x80/22c55e/ffffff?text=1200+Gems' },
                { type: 'gems', name: 'Wagon of Gems', amount: 2500, price: 399.99, currency: 'uah', imageUrl: 'https://placehold.co/100x80/22c55e/ffffff?text=2500+Gems' }
            ],
            gold: [
                { type: 'gold', name: 'Pouch of Gold', amount: 1000, price: 60, currency: 'gems', imageUrl: 'https://placehold.co/100x80/fbbf24/000000?text=1000+Gold' },
                { type: 'gold', name: 'Bucket of Gold', amount: 10000, price: 500, currency: 'gems', imageUrl: 'https://placehold.co/100x80/fbbf24/000000?text=10000+Gold' },
                { type: 'gold', name: 'Wagon of Gold', amount: 100000, price: 4500, currency: 'gems', imageUrl: 'https://placehold.co/100x80/fbbf24/000000?text=100000+Gold' }
            ]
        };

        // --- NEW: Gold and Gem SVG Icons ---
        const GOLD_ICON = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="#fbbf24"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm.75-11.25a.75.75 0 00-1.5 0v2.5h-2.5a.75.75 0 000 1.5h2.5v2.5a.75.75 0 001.5 0v-2.5h2.5a.75.75 0 000-1.5h-2.5v-2.5z" clip-rule="evenodd" /></svg>`;
        const GEM_ICON = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path d="M10.828 3.013c.252-.244.62-.244.872 0l4.243 4.13c.252.244.329.619.191.951L12.18 18.068c-.138.332-.5.549-.894.549h-2.572c-.394 0-.756-.217-.894-.549L3.874 8.094a.75.75 0 01.191-.951l4.243-4.13zM5.44 8.75L9.126 17h1.748l3.686-8.25L10.43 4.28 5.44 8.75z" fill="#22c55e" /></svg>`;

        // --- NEW: Populate Shop Tabs ---
        const dailyDealsGrid = document.getElementById('daily-deals-grid');
        const gemOffersGrid = document.getElementById('gem-offers-grid');
        const goldOffersGrid = document.getElementById('gold-offers-grid');
        let dailyDealsData = []; // ** Store generated deals **

        // ** NEW: Generate Random Daily Deals **
        function generateDailyDeals() {
            const shuffledKeys = shuffleArray(FULL_DECK_KEYS.filter(k => CARD_DECK[k].type !== 'spell')); // Don't sell spells for now
            const deals = [];
            const numDeals = 3; // We want 3 daily deals

            for (let i = 0; i < numDeals; i++) {
                const key = shuffledKeys[i];
                const card = CARD_DECK[key];
                const currency = Math.random() > 0.3 ? 'gold' : 'gems';
                let amount, price;

                if (card.rarity === 'Common') {
                    amount = (Math.floor(Math.random() * 5) + 1) * 10; // 10, 20, 30, 40, 50
                    price = (currency === 'gold') ? amount * 10 : Math.ceil(amount / 5); // 100-500 gold or 2-10 gems
                } else if (card.rarity === 'Rare') {
                    amount = (Math.floor(Math.random() * 5) + 1); // 1, 2, 3, 4, 5
                    price = (currency === 'gold') ? amount * 500 : amount * 25; // 500-2500 gold or 25-125 gems
                } else { // Epic/Legendary/Champion
                    amount = 1; // Just one
                    price = (currency === 'gold') ? 2000 : 100;
                }

                deals.push({ type: 'card', key: key, amount: amount, price: Math.round(price), currency: currency });
            }
            return deals;
        }

        function getPriceHTML(price, currency) {
            if (currency === 'gold') {
                return `<div class="shop-item-price">${GOLD_ICON} <span>${price}</span></div>`;
            }
            if (currency === 'gems') {
                return `<div class="shop-item-price gem">${GEM_ICON} <span>${price}</span></div>`;
            }
            if (currency === 'uah') {
                return `<div class="shop-item-price uah"><span>${price.toFixed(2)} UAH</span></div>`;
            }
            return `<div class="shop-item-price free"><span>FREE!</span></div>`;
        }

        // ** NEW: Purchase Simulation Function **
        function simulatePurchase(itemEl, priceEl, offer) {
            if (itemEl.classList.contains('purchased')) return; // Already bought

            // Check affordability
            if (offer.currency === 'gems' && userGems < offer.price) {
                console.log("Not enough gems!");
                // Optionally shake the button or show a message
                return; 
            }
            if (offer.currency === 'gold' && userGold < offer.price) {
                console.log("Not enough gold!");
                return;
            }
            // We assume UAH is always affordable (real money)

            // Process transaction
            if (offer.currency === 'gems') {
                userGems -= offer.price;
            }
            if (offer.currency === 'gold') {
                userGold -= offer.price;
            }

            // Add purchased item
            if (offer.type === 'gems') {
                userGems += offer.amount;
            } else if (offer.type === 'gold') {
                userGold += offer.amount;
            }
            // (We don't add 'card' types to an inventory yet, but we charge for them)

            // Update UI
            updateTopBarUI();
            
            // Show purchased state
            itemEl.classList.add('purchased');
            priceEl.classList.remove('gem', 'uah', 'free', 'shop-item-price');
            priceEl.classList.add('purchased-btn');
            priceEl.innerHTML = '‚úî –ö—É–ø–ª–µ–Ω–æ';
        }

        function initShopUI() {
            // 1. Daily Deals (NOW RANDOMIZED & SAVED)
            dailyDealsGrid.innerHTML = '';
            // ** LOGIC CHANGE: Generate deals only if they don't exist **
            if (dailyDealsData.length === 0) {
                dailyDealsData = generateDailyDeals(); // <-- Generate random deals
            }
            
            dailyDealsData.forEach(offer => { // <-- Iterate over saved deals
                const card = CARD_DECK[offer.key];
                const itemEl = document.createElement('div');
                itemEl.className = 'shop-item';
                
                const priceHTML = getPriceHTML(offer.price, offer.currency);
                
                itemEl.innerHTML = `
                    <div class="shop-item-title">${card.name} x${offer.amount}</div>
                    <div class="shop-item-image-container">
                        <div class="card-image">${CARD_SVG_GRAPHICS[offer.key] || ''}</div>
                    </div>
                    ${priceHTML}
                `;
                
                const priceEl = itemEl.querySelector('.shop-item-price');
                itemEl.addEventListener('click', () => simulatePurchase(itemEl, priceEl, offer));
                
                dailyDealsGrid.appendChild(itemEl);
            });
            
            // 2. Gem Offers
            gemOffersGrid.innerHTML = '';
            SHOP_OFFERS.gems.forEach(offer => {
                const itemEl = document.createElement('div');
                itemEl.className = 'shop-item';
                
                const priceHTML = getPriceHTML(offer.price, offer.currency);
                
                itemEl.innerHTML = `
                    <div class="shop-item-title">${offer.name}</div>
                    <div class="shop-item-image-container">
                        <img src="${offer.imageUrl}" onerror="this.src='https://placehold.co/100x80/22c55e/ffffff?text=Gems'">
                    </div>
                    ${priceHTML}
                `;
                
                const priceEl = itemEl.querySelector('.shop-item-price');
                itemEl.addEventListener('click', () => simulatePurchase(itemEl, priceEl, offer));
                
                gemOffersGrid.appendChild(itemEl);
            });
        
            // 3. Gold Offers
            goldOffersGrid.innerHTML = '';
            SHOP_OFFERS.gold.forEach(offer => {
                const itemEl = document.createElement('div');
                itemEl.className = 'shop-item';
                
                const priceHTML = getPriceHTML(offer.price, offer.currency);

                itemEl.innerHTML = `
                    <div class="shop-item-title">${offer.name}</div>
                    <div class="shop-item-image-container">
                        <img src="${offer.imageUrl}" onerror="this.src='https://placehold.co/100x80/fbbf24/000000?text=Gold'">
                    </div>
                    ${priceHTML}
                `;
                
                const priceEl = itemEl.querySelector('.shop-item-price');
                itemEl.addEventListener('click', () => simulatePurchase(itemEl, priceEl, offer));
                
                goldOffersGrid.appendChild(itemEl);
            });
        }
        
        // initCardCollectionUI(); // This is called at the end now
        // initShopUI(); // This is called at the end now
        
        function getDistance(entity1, entity2) {
            const dx = entity1.x - entity2.x;
            const dy = entity1.y - entity2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function shuffleArray(array) {
            let newArr = [...array];
            for (let i = newArr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
            }
            return newArr;
        }

        class Entity {
            constructor(x, y, width, height, health, team) {
                this.x = x;
                this.y = y;
                this.width = width; 
                this.height = height; 
                this.health = health;
                this.maxHealth = health;
                this.team = team;
                this.target = null;
                this.isAlive = true;
                this.emoji = '‚ùì';
                this.fontSize = 30; 
            }
            draw(ctx) {
                if (!this.isAlive) return; 
                
                ctx.font = `${this.fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x, this.y);
                this.drawHealthBar(ctx);
            }
            drawHealthBar(ctx) {
                const barWidth = this.width;
                const barHeight = 5;
                const yOffset = this.height / 2;
                ctx.fillStyle = '#7f1d1d'; 
                ctx.fillRect(this.x - barWidth / 2, this.y + yOffset, barWidth, barHeight);
                const healthPercent = this.health / this.maxHealth;
                ctx.fillStyle = this.team === 'player' ? '#22c55e' : '#ef4444'; 
                ctx.fillRect(this.x - barWidth / 2, this.y + yOffset, barWidth * healthPercent, barHeight);
            }
            takeDamage(amount) {
                this.health -= amount;
                if (this.health <= 0) {
                    this.health = 0;
                    this.isAlive = false;
                }
            }
            update(deltaTime, game) {}
        }

        class Effect {
            constructor(x, y, lifetime) {
                this.x = x;
                this.y = y;
                this.lifetime = lifetime;
                this.isAlive = true;
            }
            update(deltaTime) {
                this.lifetime -= deltaTime;
                if (this.lifetime <= 0) {
                    this.isAlive = false;
                }
            }
            draw(ctx) {}
        }

        class Explosion extends Effect {
            constructor(x, y, radius) {
                super(x, y, 0.5); // 0.5 second lifetime
                this.maxRadius = radius;
                this.currentRadius = 0;
            }
            update(deltaTime) {
                super.update(deltaTime);
                this.currentRadius = (1 - (this.lifetime / 0.5)) * this.maxRadius; // Scale from 0 to maxRadius
            }
            draw(ctx) {
                ctx.fillStyle = 'rgba(255, 165, 0, 0.7)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.currentRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = (this.lifetime / 0.5);
                ctx.font = '40px Arial';
                ctx.fillText('üí•', this.x, this.y);
                ctx.globalAlpha = 1;
            }
        }
        
        class ArrowRain extends Effect {
            constructor(x, y, radius) {
                super(x, y, 0.6); // 0.6 second lifetime
                this.radius = radius;
                this.arrows = [];
                for (let i=0; i < 10; i++) {
                    this.arrows.push({
                        x: this.x + (Math.random() - 0.5) * this.radius * 2,
                        y: this.y + (Math.random() - 0.5) * this.radius * 2 - 30, // Start above
                        fallSpeed: 500 + Math.random() * 200,
                        delay: Math.random() * 0.2 // Staggered fall
                    });
                }
            }
            update(deltaTime) {
                super.update(deltaTime);
                this.arrows.forEach(arrow => {
                    if (this.lifetime < (0.6 - arrow.delay)) {
                        arrow.y += arrow.fallSpeed * deltaTime;
                    }
                });
            }
            draw(ctx) {
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.globalAlpha = Math.max(0, this.lifetime / 0.6);
                this.arrows.forEach(arrow => {
                    ctx.fillText('‚Üì', arrow.x, arrow.y);
                });
                ctx.globalAlpha = 1;
            }
        }

        class Tower extends Entity {
            constructor(x, y, health, team, game) {
                super(x, y, 40, 40, health, team); 
                this.game = game;
                this.attackRange = 150; 
                this.attackSpeed = 1.2; 
                this.attackWindup = 0.1; 
                this.attackCooldownTime = 1 / this.attackSpeed;
                this.attackTimer = 0;
                this.state = 'IDLE';
                
                // NEW: Building lifetime
                this.isBuilding = false;
                this.lifetime = null;
            }

            draw(ctx) {
                if (!this.isAlive) {
                    ctx.font = `30px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.globalAlpha = 0.7;
                    ctx.fillText('üß±', this.x, this.y); 
                    ctx.globalAlpha = 1.0;
                    return; 
                }
                
                // ** NEW: Style buildings differently **
                if (this.isBuilding) {
                     ctx.fillStyle = '#854d0e'; // Brown
                     ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                     ctx.fillStyle = '#a16207'; // Lighter brown
                     ctx.fillRect(this.x - this.width/2 + 5, this.y - this.height/2 + 5, this.width-10, this.height-10);
                } else {
                    ctx.fillStyle = '#4a4a4a'; // Dark grey base
                    ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                }
                
                ctx.font = `${this.fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x, this.y);
                
                this.drawHealthBar(ctx);
            }

            update(deltaTime, game) {
                if (!this.isAlive) return;
                
                // NEW: Handle building lifetime
                if (this.isBuilding && this.lifetime !== null) {
                    this.lifetime -= deltaTime;
                    if (this.lifetime <= 0) {
                        this.isAlive = false;
                        return;
                    }
                }
                
                this.attackTimer -= deltaTime;
                
                // ** AI LOGIC v7.1 (Critical Fix) **
                
                // 1. Find Target if needed
                if (!this.target || !this.target.isAlive || getDistance(this, this.target) > this.attackRange) {
                    this.findTarget(game.entities);
                }

                if (this.state === 'IDLE') {
                    if (this.target && this.attackTimer <= 0) {
                        this.state = 'ATTACKING';
                        this.attackTimer = this.attackWindup;
                    }
                } else if (this.state === 'ATTACKING') {
                    if (this.attackTimer <= 0) {
                        if (this.target && this.target.isAlive && getDistance(this, this.target) <= this.attackRange) {
                            this.attack();
                        }
                        this.attackTimer = this.attackCooldownTime; 
                        this.state = 'IDLE';
                    }
                }
            }
            findTarget(allEntities) {
                let closestTarget = null; 
                let minDistance = this.attackRange;

                for (const entity of allEntities) {
                    if (entity.team !== this.team && entity.isAlive) {
                        const distance = getDistance(this, entity);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestTarget = entity;
                        }
                    }
                }
                this.target = closestTarget;
            }
            attack() {
                this.game.addProjectile(new Projectile(this.x, this.y - this.height / 2, this.target, 35, this.team, '‚ö´', 15));
            }
        }
        
        class KingTower extends Tower {
            constructor(x, y, health, team, game) {
                super(x, y, health, team, game);
                this.emoji = 'üëë';
                this.fontSize = 35; 
                this.width = 50; 
                this.height = 50;
                this.isKing = true;
            }
        }
        
        class PrincessTower extends Tower {
             constructor(x, y, health, team, game) {
                super(x, y, health, team, game);
                this.emoji = 'üèπ'; 
                this.fontSize = 30; 
                this.isKing = false;
            }
        }
        
        // NEW: Cannon Building Class
        class Cannon extends Tower {
             constructor(x, y, team, game) {
                const stats = CARD_DECK.cannon.stats;
                super(x, y, stats.hp, team, game);
                this.emoji = 'üí£'; 
                this.fontSize = 30; 
                this.isKing = false;
                this.isBuilding = true; // Mark as building
                this.lifetime = stats.lifetime;
                
                // Set stats from deck
                this.attackRange = stats.range * 25; // 5.5 * 25 = 137.5
                this.attackSpeed = stats.attackSpeed;
                this.attackWindup = 0.2; // Custom
                this.attackCooldownTime = 1 / this.attackSpeed;
                this.attackDamage = stats.damage;
            }
            
            // Cannon only targets ground
            findTarget(allEntities) {
                let closestTarget = null; 
                let minDistance = this.attackRange;

                for (const entity of allEntities) {
                    // FIXME: Add check for ground-only
                    if (entity.team !== this.team && entity.isAlive) {
                        const distance = getDistance(this, entity);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestTarget = entity;
                        }
                    }
                }
                this.target = closestTarget;
            }
            
            attack() {
                this.game.addProjectile(new Projectile(this.x, this.y - this.height / 2, this.target, this.attackDamage, this.team, '‚ö´', 15));
            }
            
            draw(ctx) {
                super.draw(ctx); // Call parent draw (handles healthbar, etc.)
                
                // Draw lifetime bar
                if (this.isAlive && this.lifetime !== null) {
                    const barWidth = this.width;
                    const barHeight = 4;
                    const yOffset = (this.height / 2) + 8; // Below healthbar
                    ctx.fillStyle = '#4b5563'; 
                    ctx.fillRect(this.x - barWidth / 2, this.y + yOffset, barWidth, barHeight);
                    const lifePercent = this.lifetime / CARD_DECK.cannon.stats.lifetime;
                    ctx.fillStyle = '#e2e8f0'; 
                    ctx.fillRect(this.x - barWidth / 2, this.y + yOffset, barWidth * lifePercent, barHeight);
                }
            }
        }


        class Unit extends Entity {
            constructor(x, y, width, height, health, team, speed, attackRange, attackDamage, attackSpeed, sightRange, attackWindup, targetType = 'Ground') {
                super(x, y, width, height, health, team);
                this.speed = speed;
                this.attackRange = attackRange * 25; // Convert range to pixels (e.g., 1.2 * 25 = 30px)
                this.attackDamage = attackDamage;
                this.attackSpeed = attackSpeed;
                this.sightRange = sightRange * 25; // Convert range to pixels
                this.lane = (x < canvas.width / 2) ? 'left' : 'right';
                this.attackWindup = attackWindup;
                this.attackCooldownTime = 1 / attackSpeed;
                this.attackTimer = 0; 
                this.state = 'IDLE';
                this.isAggroed = false; 
                this.targetType = targetType; // NEW: 'Ground', 'Buildings', 'Air & Ground'
            }
            
            // ** AI LOGIC v7.1 (Critical Fix) **
            update(deltaTime, game) {
                if (!this.isAlive) return;
                this.attackTimer -= deltaTime;

                // --- 1. TARGET ACQUISITION (–ü–æ—à—É–∫ —Ü—ñ–ª—ñ) ---
                // (v8.1 Fix: This logic was flawed, reverting to a more robust check)
                if (this.state === 'ATTACKING') {
                     // In windup, do nothing
                     if (this.attackTimer > 0) {
                         return;
                     }
                     
                     // Windup finished, perform attack
                     if (this.target && this.target.isAlive && getDistance(this, this.target) <= this.attackRange) {
                         this.attack(this.target); 
                     }
                     this.attackTimer = this.attackCooldownTime; // Start cooldown
                     this.state = 'IDLE';
                     // After attacking, fall through to IDLE state to re-evaluate
                }
                
                // --- Find Target ---
                // (v8.1 Fix) We find a target if we don't have one, or if it's dead, OR if we are just walking (MOVING)
                if (!this.target || !this.target.isAlive || this.state === 'MOVING') {
                    if (this.target && !this.target.isAlive) {
                        this.target = null;
                        this.isAggroed = false;
                    }
                    this.findTarget(game);
                }
                
                // If still no target, do nothing
                if (!this.target) {
                    this.state = 'IDLE';
                    return; 
                }
                
                // --- 2. STATE MACHINE (–ú–∞—à–∏–Ω–∞ —Å—Ç–∞–Ω—ñ–≤) ---
                const distance = getDistance(this, this.target);

                if (this.state === 'IDLE') {
                    if (distance <= this.attackRange) {
                        if (this.attackTimer <= 0) { 
                            this.state = 'ATTACKING';
                            this.attackTimer = this.attackWindup; 
                        }
                    } else {
                        // (v8.1 Fix) Target is alive but out of range
                        this.state = 'MOVING';
                    }
                } else if (this.state === 'MOVING') {
                    if (distance <= this.attackRange) {
                        this.state = 'IDLE'; // Arrived at target
                    } else {
                        this.move(deltaTime, this.target); 
                    }
                }
            }
            
            findTarget(game) {
                const enemyTeam = this.team === 'player' ? 'ai' : 'player';
                const enemyEntities = game.entities.filter(e => e.team === enemyTeam && e.isAlive);
                let closestTarget = null;
                let minDistance = this.sightRange; 
                
                // --- NEW Target Logic ---
                // 1. If this unit targets buildings...
                if (this.targetType === 'Buildings') {
                    const enemyTowers = game.getTowers(enemyTeam);
                    if (this.lane === 'left' && enemyTowers.left.isAlive) {
                        this.target = enemyTowers.left;
                    } else if (this.lane === 'right' && enemyTowers.right.isAlive) {
                        this.target = enemyTowers.right;
                    } else {
                        this.target = enemyTowers.king;
                    }
                    return; // Found target, exit
                }

                // 2. This unit targets Ground (or Air & Ground)
                // (FIXME: We treat Air & Ground same as Ground for now)
                for (const entity of enemyEntities) {
                    const distance = getDistance(this, entity);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestTarget = entity;
                    }
                }
                
                if (closestTarget) {
                    this.target = closestTarget;
                    this.isAggroed = true;
                    return; 
                }
                
                // 3. No units found, target tower
                if (this.isAggroed || !this.target || !this.target.isAlive) {
                    this.isAggroed = false; 
                    const enemyTowers = game.getTowers(enemyTeam);
                    if (this.lane === 'left' && enemyTowers.left.isAlive) {
                        this.target = enemyTowers.left;
                    } else if (this.lane === 'right' && enemyTowers.right.isAlive) {
                        this.target = enemyTowers.right;
                    } else {
                        this.target = enemyTowers.king;
                    }
                }
            }


            move(deltaTime, target) {
                const w = canvas.width;
                const h = canvas.height;
                const midY = h / 2;
                let waypoint = { x: target.x, y: target.y };
                const onMyStartingSide = (this.team === 'player' && this.y > midY) || (this.team === 'ai' && this.y < midY);
                const targetOnMySide = (this.team === 'player' && target.y > midY) || (this.team === 'ai' && target.y < midY);
                if (onMyStartingSide && !targetOnMySide) {
                    const laneX = (this.lane === 'left') ? (w / 4) : (w * 3 / 4); 
                    const bridgeWaypointY = (this.team === 'player') ? (midY - 30) : (midY + 30); 
                    waypoint.x = laneX;
                    waypoint.y = bridgeWaypointY;
                }
                this.moveToWaypoint(deltaTime, waypoint);
            }
            moveToWaypoint(deltaTime, waypoint) {
                const angle = Math.atan2(waypoint.y - this.y, waypoint.x - this.x);
                const distanceToWaypoint = getDistance(this, waypoint);
                if (distanceToWaypoint > this.speed * deltaTime) { 
                    this.x += Math.cos(angle) * this.speed * deltaTime;
                    this.y += Math.sin(angle) * this.speed * deltaTime;
                } else if (distanceToWaypoint > 5) {
                    this.x = waypoint.x;
                    this.y = waypoint.y;
                }
            }
            attack(target) {
                target.takeDamage(this.attackDamage);
            }
        }

        class Knight extends Unit {
            constructor(x, y, team) {
                const stats = CARD_DECK.knight.stats;
                super(x, y, 30, 30, stats.hp, team, 40, stats.range, stats.damage, stats.attackSpeed, 6, 0.4, 'Ground'); 
                this.emoji = 'üõ°Ô∏è';
                this.fontSize = 30;
            }
        }
        
        class Archer extends Unit {
            constructor(x, y, team, game) {
                const stats = CARD_DECK.archers.stats;
                super(x, y, 25, 25, stats.hp, team, 40, stats.range, stats.damage, stats.attackSpeed, 7, 0.2, 'Air & Ground');
                this.game = game;
                this.emoji = 'üèπ';
                this.fontSize = 30;
            }
            attack(target) {
                this.game.addProjectile(new Projectile(this.x, this.y, target, this.attackDamage, this.team, '‚û°Ô∏è', 15));
            }
        }

        class Goblin extends Unit {
            constructor(x, y, team) {
                const stats = CARD_DECK.goblins.stats;
                super(x, y, 25, 25, stats.hp, team, 60, stats.range, stats.damage, stats.attackSpeed, 6, 0.3, 'Ground'); 
                this.emoji = 'üü¢';
                this.fontSize = 25;
            }
        }

        class MiniPekka extends Unit {
            constructor(x, y, team) {
                const stats = CARD_DECK.miniPekka.stats;
                super(x, y, 35, 35, stats.hp, team, 40, stats.range, stats.damage, stats.attackSpeed, 6, 0.8, 'Ground'); 
                this.emoji = 'ü§ñ';
                this.fontSize = 35;
            }
        }

        class Wizard extends Unit {
             constructor(x, y, team, game) {
                const stats = CARD_DECK.wizard.stats;
                super(x, y, 30, 30, stats.hp, team, 40, stats.range, stats.damage, stats.attackSpeed, 7, 0.4, 'Air & Ground');
                this.game = game;
                this.emoji = 'üßô';
                this.fontSize = 35;
            }
            attack(target) {
                // FIXME: Wizard should do splash damage. Using projectile for now.
                this.game.addProjectile(new Projectile(this.x, this.y, target, this.attackDamage, this.team, '‚ú®', 20));
            }
        }

        class Giant extends Unit {
            constructor(x, y, team) {
                const stats = CARD_DECK.giant.stats;
                super(x, y, 40, 40, stats.hp, team, 25, stats.range, stats.damage, stats.attackSpeed, 7, 0.6, 'Buildings');
                this.emoji = 'üëπ';
                this.fontSize = 40;
            }
            
            // This unit only targets buildings
            findTarget(game) {
                const enemyTowers = game.getTowers(this.team === 'player' ? 'ai' : 'player');
                if (this.lane === 'left' && enemyTowers.left.isAlive) this.target = enemyTowers.left;
                else if (this.lane === 'right' && enemyTowers.right.isAlive) this.target = enemyTowers.right;
                else this.target = enemyTowers.king;
            }
            
            update(deltaTime, game) {
                if (!this.isAlive) return;
                this.attackTimer -= deltaTime;
                
                if (!this.target || !this.target.isAlive) {
                    this.findTarget(game);
                }
                if (!this.target) return; 
                
                const distance = getDistance(this, this.target);

                if (this.state === 'ATTACKING') {
                    if (this.attackTimer <= 0) { 
                        if (this.target && this.target.isAlive && getDistance(this, this.target) <= this.attackRange) {
                            this.attack(this.target);
                        }
                        this.attackTimer = this.attackCooldownTime;
                        this.state = 'IDLE'; 
                    }
                } else if (this.state === 'IDLE') {
                    if (distance <= this.attackRange) {
                        if (this.attackTimer <= 0) { 
                            this.state = 'ATTACKING';
                            this.attackTimer = this.attackWindup; 
                        }
                    } else {
                        this.state = 'MOVING'; 
                    }
                } else if (this.state === 'MOVING') {
                    if (distance <= this.attackRange) {
                        this.state = 'IDLE'; 
                    } else {
                        this.move(deltaTime, this.target); 
                    }
                }
            }
        }
        
        // --- NEW/UPDATED UNITS ---
        class LavaHound extends Unit {
            constructor(x, y, team, game) {
                const stats = CARD_DECK.lavaHound.stats;
                super(x, y, 40, 40, stats.hp, team, 25, stats.range, stats.damage, stats.attackSpeed, 7, 0.6, 'Buildings');
                this.game = game;
                this.emoji = 'üî•';
                this.fontSize = 40;
            }
            
            findTarget(game) { // Copy from Giant
                const enemyTowers = game.getTowers(this.team === 'player' ? 'ai' : 'player');
                if (this.lane === 'left' && enemyTowers.left.isAlive) this.target = enemyTowers.left;
                else if (this.lane === 'right' && enemyTowers.right.isAlive) this.target = enemyTowers.right;
                else this.target = enemyTowers.king;
            }
            
            update(deltaTime, game) { // Copy from Giant
                super.update(deltaTime, game);
            }
            
            attack(target) { // Ranged attack
                this.game.addProjectile(new Projectile(this.x, this.y, target, this.attackDamage, this.team, 'üî•', 15));
            }
        }
        
        class ArcherQueen extends Unit {
             constructor(x, y, team, game) {
                const stats = CARD_DECK.archerQueen.stats;
                super(x, y, 30, 30, stats.hp, team, 40, stats.range, stats.damage, stats.attackSpeed, 7, 0.2, 'Air & Ground');
                this.game = game;
                this.emoji = 'üëë';
                this.fontSize = 35;
            }
            attack(target) { // Copy from Archer
                this.game.addProjectile(new Projectile(this.x, this.y, target, this.attackDamage, this.team, '‚û°Ô∏è', 15));
            }
        }
        
        class Musketeer extends Unit {
             constructor(x, y, team, game) {
                const stats = CARD_DECK.musketeer.stats;
                super(x, y, 30, 30, stats.hp, team, 40, stats.range, stats.damage, stats.attackSpeed, 8, 0.2, 'Air & Ground');
                this.game = game;
                this.emoji = 'üéØ';
                this.fontSize = 30;
            }
            attack(target) {
                this.game.addProjectile(new Projectile(this.x, this.y, target, this.attackDamage, this.team, '‚ö´', 10)); // Simple bullet
            }
        }
        
        class Valkyrie extends Unit {
            constructor(x, y, team) {
                const stats = CARD_DECK.valkyrie.stats;
                super(x, y, 30, 30, stats.hp, team, 40, stats.range, stats.damage, stats.attackSpeed, 6, 0.4, 'Ground'); 
                this.emoji = 'ü™ì';
                this.fontSize = 30;
            }
            // FIXME: Valkyrie should do splash damage.
        }
        
        class HogRider extends Unit {
            constructor(x, y, team) {
                const stats = CARD_DECK.hogRider.stats;
                super(x, y, 35, 35, stats.hp, team, 60, stats.range, stats.damage, stats.attackSpeed, 7, 0.6, 'Buildings');
                this.emoji = 'üî®';
                this.fontSize = 35;
            }
            findTarget(game) { // Copy from Giant
                const enemyTowers = game.getTowers(this.team === 'player' ? 'ai' : 'player');
                if (this.lane === 'left' && enemyTowers.left.isAlive) this.target = enemyTowers.left;
                else if (this.lane === 'right' && enemyTowers.right.isAlive) this.target = enemyTowers.right;
                else this.target = enemyTowers.king;
            }
            update(deltaTime, game) { // Copy from Giant
                super.update(deltaTime, game);
            }
        }
        
        class Skeleton extends Unit {
             constructor(x, y, team) {
                const stats = CARD_DECK.skeletonArmy.stats; // Use army stats for one skeleton
                super(x, y, 20, 20, stats.hp, team, 50, stats.range, stats.damage, stats.attackSpeed, 6, 0.3, 'Ground'); 
                this.emoji = 'üíÄ';
                this.fontSize = 20;
            }
        }
        
        class Minion extends Unit {
             constructor(x, y, team, game) {
                const stats = CARD_DECK.minions.stats;
                super(x, y, 25, 25, stats.hp, team, 50, stats.range, stats.damage, stats.attackSpeed, 7, 0.2, 'Air & Ground'); 
                this.game = game;
                this.emoji = 'ü¶á';
                this.fontSize = 25;
            }
            attack(target) {
                this.game.addProjectile(new Projectile(this.x, this.y, target, this.attackDamage, this.team, 'üü£', 8)); // Small bolt
            }
        }

        // --- End of Unit Classes ---

        class Projectile {
            constructor(x, y, target, damage, team, emoji, size) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.damage = damage;
                this.team = team;
                this.speed = 300;
                this.isAlive = true;
                this.emoji = emoji;
                this.fontSize = size;
            }
            update(deltaTime) {
                if (!this.isAlive || !this.target.isAlive) {
                    this.isAlive = false;
                    return;
                }
                const distance = getDistance(this, {x: this.target.x, y: this.target.y});
                if (distance < 10) { 
                    this.onHit();
                    return;
                }
                const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                this.x += Math.cos(angle) * this.speed * deltaTime;
                this.y += Math.sin(angle) * this.speed * deltaTime;
            }
            onHit() {
                this.target.takeDamage(this.damage);
                this.isAlive = false;
            }
            draw(ctx) {
                ctx.font = `${this.fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x, this.y);
            }
        }
        
        // RE-ADDED: Fireball Class
        class Fireball extends Projectile {
            constructor(x, y, targetX, targetY, damage, team, game) {
                const pseudoTarget = { x: targetX, y: targetY, isAlive: true };
                super(x, y, pseudoTarget, damage, team, 'üî•', 30);
                this.game = game;
                this.aoeRadius = CARD_DECK.fireball.stats.range * 24; // 2.5 * 24 = 60
                this.speed = 250;
            }
            onHit() {
                this.isAlive = false;
                this.game.addEffect(new Explosion(this.x, this.y, this.aoeRadius)); 
                const allEntities = [...this.game.entities, ...this.game.getAllTowers()];
                for (const entity of allEntities) {
                    if (entity.team !== this.team && entity.isAlive) {
                        const distance = getDistance(this, entity);
                        if (distance <= this.aoeRadius) {
                            entity.takeDamage(this.damage);
                        }
                    }
                }
            }
            draw(ctx) {
                const size = this.fontSize + (this.y / canvas.height) * 15;
                ctx.font = `${size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x, this.y);
            }
        }

        class Game {
            constructor(ctx) {
                this.ctx = ctx;
                this.entities = [];
                this.projectiles = [];
                this.effects = []; 
                const w = canvas.width;
                const h = canvas.height;
                
                this.playerKingTower = new KingTower(w / 2, h - 50, 1500, 'player', this);
                this.playerLeftTower = new PrincessTower(w / 4, h - 150, 1000, 'player', this);
                this.playerRightTower = new PrincessTower(w * 3 / 4, h - 150, 1000, 'player', this);
                this.aiKingTower = new KingTower(w / 2, 50, 1500, 'ai', this);
                this.aiLeftTower = new PrincessTower(w / 4, 150, 1000, 'ai', this);
                this.aiRightTower = new PrincessTower(w * 3 / 4, 150, 1000, 'ai', this);
                
                this.aiTrainer = TRAINER_LIST[Math.floor(Math.random() * TRAINER_LIST.length)];
                
                this.playerElixir = 5;
                this.aiElixir = 5;
                this.aiSpawnTimer = 4;
                this.gameState = GAME_STATE.RUNNING;
                this.lastTime = 0;
                this.animationFrameId = null;
                
                this.playerFullDeck = []; // This will be the 8-card deck
                this.playerHand = [];
                this.playerDeckQueue = [];
                this.aiFullDeck = []; // This will be the AI's 8 cards
                this.aiHand = [];
                this.aiDeckQueue = [];
                
                this.selectedCard = null; 
                
                // *** –ù–û–í–ò–ô –ö–û–î: –î–æ–¥–∞–Ω–æ –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è –∫—É—Ä—Å–æ—Ä–∞ ***
                this.cursorPosition = { x: -100, y: -100 }; // –ü–æ—á–∞—Ç–∫–æ–≤–∞ –ø–æ–∑–∏—Ü—ñ—è –∑–∞ –µ–∫—Ä–∞–Ω–æ–º
                this.isCursorOnCanvas = false;
                // *** –ö–Ü–ù–ï–¶–¨ –ù–û–í–û–ì–û –ö–û–î–£ ***
            }
            getTowers(team) {
                if (team === 'player') return { king: this.playerKingTower, left: this.playerLeftTower, right: this.playerRightTower };
                else return { king: this.aiKingTower, left: this.aiLeftTower, right: this.aiRightTower };
            }
            getAllTowers() {
                return [this.playerKingTower, this.playerLeftTower, this.playerRightTower, this.aiKingTower, this.aiLeftTower, this.aiRightTower];
            }
            addProjectile(projectile) { this.projectiles.push(projectile); }
            addEffect(effect) { this.effects.push(effect); } 

            initDecks() {
                // === NEW DECK LOGIC ===
                // 'playerFullDeck' in the game context is the 8-card battle deck
                this.playerFullDeck = shuffleArray(playerBattleDeck); 
                
                this.playerHand = this.playerFullDeck.slice(0, 4);
                this.playerDeckQueue = this.playerFullDeck.slice(4, 8); // Get the other 4 cards
                
                // AI still uses random 8 cards from the full set
                this.aiFullDeck = shuffleArray(FULL_DECK_KEYS); 
                this.aiHand = this.aiFullDeck.slice(0, 4);
                this.aiDeckQueue = this.aiFullDeck.slice(4, 8);
                // === END NEW DECK LOGIC ===
                
                this.updateCardHandUI();
            }
            
            rotateDeck(team, playedCardIndex) {
                const hand = (team === 'player') ? this.playerHand : this.aiHand;
                const queue = (team === 'player') ? this.playerDeckQueue : this.aiDeckQueue;
                
                const playedCardKey = hand.splice(playedCardIndex, 1)[0];
                const nextCardKey = queue.shift();
                
                hand.push(nextCardKey);
                queue.push(playedCardKey);
            }

            // REVERTED: Back to selectCard
            selectCard(index) {
                const cardKey = this.playerHand[index];
                if (!cardKey) return;
                const card = CARD_DECK[cardKey];
                
                // Logic to select/deselect
                if (this.selectedCard && this.selectedCard.index === index) {
                    // Deselect
                    this.selectedCard = null;
                } else if (this.playerElixir >= card.cost) {
                    // Select
                    this.selectedCard = { index: index, key: cardKey, cost: card.cost, type: card.type };
                }
                
                this.updateCardHandUI();
            }
            
            // *** RESTORED: handleCanvasClick ***
            handleCanvasClick(e) {
                if (!this.selectedCard || this.gameState !== GAME_STATE.RUNNING) return;
                
                const x = e.clientX - canvasRect.left;
                const y = e.clientY - canvasRect.top;
                
                // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –Ω–æ–≤—É, —Å–∫–ª–∞–¥–Ω—ñ—à—É –ø–µ—Ä–µ–≤—ñ—Ä–∫—É
                const cardKey = this.selectedCard.key; // Get card key
                if (!this.isDeploymentAllowed(x, y, cardKey)) { // Pass key
                    console.log("–ù–µ–ø—Ä–∏–ø—É—Å—Ç–∏–º–µ –º—ñ—Å—Ü–µ —Ä–æ–∑–º—ñ—â–µ–Ω–Ω—è!");
                    return; // –ó–∞–±–æ—Ä–æ–Ω—è—î–º–æ —Ä–æ–∑–º—ñ—â–µ–Ω–Ω—è
                }
                
                // –Ø–∫—â–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø—Ä–æ–π–¥–µ–Ω–∞, —Ä–æ–∑–º—ñ—â—É—î–º–æ –∫–∞—Ä—Ç—É
                this.spawnCard(cardKey, 'player', x, y);
                this.playerElixir -= this.selectedCard.cost;
                
                this.rotateDeck('player', this.selectedCard.index); 
                
                this.selectedCard = null;
                this.updateCardHandUI();
            }
            // *** END RESTORED ***
            
            // RE-ADDED: spawnArrows
            spawnArrows(x, y, team) {
                const stats = CARD_DECK.arrows.stats;
                this.addEffect(new ArrowRain(x, y, stats.range * 25)); // 3.5 * 25 = 87.5
                const damage = stats.damage;
                const aoeRadius = stats.range * 25; 
                
                const allEntities = [...this.entities, ...this.getAllTowers()];
                for (const entity of allEntities) {
                    if (entity.team !== team && entity.isAlive) {
                        const distance = getDistance({x: x, y: y}, entity);
                        if (distance <= aoeRadius) {
                            entity.takeDamage(damage);
                        }
                    }
                }
            }
            
            // RE-ADDED: spawnZap
            spawnZap(x, y, team) {
                const stats = CARD_DECK.zap.stats;
                this.addEffect(new Explosion(x, y, stats.range * 25)); // 2.5 * 25 = 62.5
                
                const allEntities = [...this.entities, ...this.getAllTowers()];
                for (const entity of allEntities) {
                    if (entity.team !== team && entity.isAlive) {
                        const distance = getDistance({x: x, y: y}, entity);
                        if (distance <= (stats.range * 25)) {
                            entity.takeDamage(stats.damage);
                        }
                    }
                }
            }
            
            spawnCard(cardKey, team, x, y) {
                const base = (team === 'player') ? this.playerKingTower : this.aiKingTower;
                switch (cardKey) {
                    case 'knight':
                        this.entities.push(new Knight(x, y, team));
                        break;
                    case 'archers': 
                        this.entities.push(new Archer(x - 10, y, team, this));
                        this.entities.push(new Archer(x + 10, y + 5, team, this)); 
                        break;
                    case 'giant':
                        this.entities.push(new Giant(x, y, team));
                        break;
                    case 'wizard':
                        this.entities.push(new Wizard(x, y, team, this));
                        break;
                    case 'goblins':
                        // Spawn 4 goblins
                        this.entities.push(new Goblin(x - 10, y - 5, team));
                        this.entities.push(new Goblin(x + 10, y - 5, team));
                        this.entities.push(new Goblin(x - 10, y + 5, team));
                        this.entities.push(new Goblin(x + 10, y + 5, team));
                        break;
                    case 'miniPekka':
                        this.entities.push(new MiniPekka(x, y, team));
                        break;
                    case 'lavaHound':
                        this.entities.push(new LavaHound(x, y, team, this));
                        break;
                    case 'archerQueen':
                        this.entities.push(new ArcherQueen(x, y, team, this));
                        break;
                    case 'musketeer':
                        this.entities.push(new Musketeer(x, y, team, this));
                        break;
                    case 'valkyrie':
                        this.entities.push(new Valkyrie(x, y, team));
                        break;
                    case 'hogRider':
                        this.entities.push(new HogRider(x, y, team));
                        break;
                    case 'skeletonArmy':
                        // Spawn 15 skeletons
                        for (let i = 0; i < 15; i++) {
                            const spawnX = x + (Math.random() - 0.5) * 60;
                            const spawnY = y + (Math.random() - 0.5) * 60;
                            this.entities.push(new Skeleton(spawnX, spawnY, team));
                        }
                        break;
                    case 'minions':
                         // Spawn 3 minions
                        this.entities.push(new Minion(x, y, team, this));
                        this.entities.push(new Minion(x - 15, y - 5, team, this));
                        this.entities.push(new Minion(x + 15, y - 5, team, this));
                        break;
                    // RE-ADDED Spells & Buildings
                    case 'fireball':
                        const fbSpawnX = (team === 'player') ? base.x : base.x;
                        const fbSpawnY = (team === 'player') ? base.y - 50 : base.y + 50;
                        this.addProjectile(new Fireball(fbSpawnX, fbSpawnY, x, y, CARD_DECK.fireball.stats.damage, team, this));
                        break;
                    case 'arrows':
                        this.spawnArrows(x, y, team);
                        break;
                    case 'zap':
                        this.spawnZap(x, y, team);
                        break;
                    case 'cannon':
                        this.entities.push(new Cannon(x, y, team, this)); // Add Cannon as an entity
                        break;
                }
            }
            
            runAI(deltaTime) {
                this.aiSpawnTimer -= deltaTime;
                if (this.aiSpawnTimer <= 0) {
                    this.aiSpawnTimer = Math.random() * 3 + 4; 
                    let cardToPlay = null;
                    let cardIndex = -1;
                    
                    for (let i = 0; i < this.aiHand.length; i++) {
                        const key = this.aiHand[i];
                        if (this.aiElixir >= CARD_DECK[key].cost) {
                            cardToPlay = key;
                            cardIndex = i;
                            break;
                        }
                    }
                    
                    if (cardToPlay) {
                        this.aiElixir -= CARD_DECK[cardToPlay].cost;
                        // AI —Ä–æ–∑–º—ñ—â—É—î —é–Ω—ñ—Ç—ñ–≤ –ª–∏—à–µ –Ω–∞ —Å–≤–æ—ó–π (–≤–µ—Ä—Ö–Ω—ñ–π) –ø–æ–ª–æ–≤–∏–Ω—ñ
                        const spawnX = Math.random() < 0.5 ? (canvas.width / 4) : (canvas.width * 3 / 4);
                        const spawnY = 150 + (Math.random() * 50); // –ó–æ–Ω–∞ AI
                        
                        // AI —Ä–æ–∑–º—ñ—â—É—î –∑–∞–∫–ª—è—Ç—Ç—è –Ω–∞ —Å—Ç–æ—Ä–æ–Ω—ñ –≥—Ä–∞–≤—Ü—è
                        const cardType = CARD_DECK[cardToPlay].type;
                        let finalSpawnX = spawnX;
                        let finalSpawnY = spawnY;
                        
                        if(cardType === 'spell') {
                            finalSpawnX = Math.random() < 0.5 ? (canvas.width / 4) : (canvas.width * 3 / 4);
                            finalSpawnY = canvas.height - 150 - (Math.random() * 50); // –ó–æ–Ω–∞ –≥—Ä–∞–≤—Ü—è
                        }
                        
                        this.spawnCard(cardToPlay, 'ai', finalSpawnX, finalSpawnY);
                        
                        this.rotateDeck('ai', cardIndex); 
                    }
                }
            }
            
            updateCardHandUI() {
                // 1. Update Hand
                cardHandContainer.innerHTML = ''; 
                this.playerHand.forEach((cardKey, index) => {
                    if (!cardKey) return; 
                    const card = CARD_DECK[cardKey];
                    const cardEl = document.createElement('div');
                    cardEl.className = `card rarity-${card.rarity.toLowerCase()}`; // Add rarity
                    cardEl.dataset.index = index;
                    if (this.playerElixir < card.cost) cardEl.classList.add('disabled');
                    
                    // NEW: Highlight if selected
                    if (this.selectedCard && this.selectedCard.index === index) {
                        cardEl.classList.add('selected');
                    }
                    
                    cardEl.innerHTML = `
                        <div class="card-cost">${card.cost}</div>
                        <div class="card-image">${CARD_SVG_GRAPHICS[cardKey] || ''}</div>
                        <div class="card-name">${card.name}</div>
                    `;
                    // REVERTED: back to 'click' and 'selectCard'
                    cardEl.addEventListener('click', () => this.selectCard(index));
                    cardHandContainer.appendChild(cardEl);
                });
                
                // 2. Update "Next" card preview
                // *** THIS IS THE LOGIC FOR "NEXT CARD" ***
                const nextCardKey = this.playerDeckQueue[0];
                if (nextCardKey) {
                    const card = CARD_DECK[nextCardKey];
                    nextCardPreview.className = `rarity-${card.rarity.toLowerCase()}`; // Add rarity
                    nextCardPreview.innerHTML = `
                        <div class="card-cost">${card.cost}</div>
                        <div class="next-card-image">${CARD_SVG_GRAPHICS[nextCardKey] || ''}</div>
                        <div class="card-name">${card.name}</div>
                    `;
                } else {
                    nextCardPreview.innerHTML = ''; 
                    nextCardPreview.className = ''; // Clear rarity class if no card
                }
                
                // REMOVED: Old re-select logic
            }
            
            update(deltaTime) {
                if (this.gameState !== GAME_STATE.RUNNING) return;
                this.playerElixir = Math.min(ELIXIR_MAX, this.playerElixir + ELIXIR_REGEN_RATE * deltaTime);
                this.aiElixir = Math.min(ELIXIR_MAX, this.aiElixir + ELIXIR_REGEN_RATE * deltaTime);
                this.runAI(deltaTime);
                
                this.getAllTowers().forEach(t => t.update(deltaTime, this));
                [...this.entities].forEach(e => e.update(deltaTime, this));
                [...this.projectiles].forEach(p => p.update(deltaTime));
                [...this.effects].forEach(e => e.update(deltaTime)); 
                
                this.entities = this.entities.filter(e => e.isAlive);
                this.projectiles = this.projectiles.filter(p => p.isAlive);
                this.effects = this.effects.filter(e => e.isAlive); 
                
                if (!this.playerKingTower.isAlive) {
                    this.gameState = GAME_STATE.AI_WINS;
                    messageText.innerText = 'YOU LOSE!';
                    message.classList.remove('hidden');
                } else if (!this.aiKingTower.isAlive) {
                    this.gameState = GAME_STATE.PLAYER_WINS;
                    messageText.innerText = 'YOU WIN!';
                    message.classList.remove('hidden');
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, canvas.width, canvas.height);
                const w = canvas.width;
                const h = canvas.height;
                const midY = h / 2;
                
                // 1. Draw checkerboard background
                const tileSize = 40; 
                const lightGreen = '#6aa84f';
                const darkGreen = '#5a943f';
                for (let r = 0; r * tileSize < h; r++) {
                    for (let c = 0; c * tileSize < w; c++) {
                        ctx.fillStyle = ((r + c) % 2 === 0) ? lightGreen : darkGreen;
                        ctx.fillRect(c * tileSize, r * tileSize, tileSize, tileSize);
                    }
                }
                
                // 2. *** Draw Paths with 90-degree angles (Final Version) ***
                ctx.strokeStyle = '#d2b48c'; // Sand color
                ctx.lineWidth = 10;
                ctx.lineCap = 'butt'; 
                
                const aiKing = {x: this.aiKingTower.x, y: this.aiKingTower.y};
                const aiLeft = {x: this.aiLeftTower.x, y: this.aiLeftTower.y};
                const aiRight = {x: this.aiRightTower.x, y: this.aiRightTower.y};
                const playerKing = {x: this.playerKingTower.x, y: this.playerKingTower.y};
                const playerLeft = {x: this.playerLeftTower.x, y: this.playerLeftTower.y};
                const playerRight = {x: this.playerRightTower.x, y: this.playerRightTower.y};
                const leftBridge = {x: w / 4, y: midY};
                const rightBridge = {x: w * 3 / 4, y: midY};
                
                ctx.beginPath();
                
                // AI Paths (Main lanes - 90 deg)
                ctx.moveTo(leftBridge.x, leftBridge.y - 25);
                ctx.lineTo(aiLeft.x, aiLeft.y);
                ctx.moveTo(rightBridge.x, rightBridge.y - 25);
                ctx.lineTo(aiRight.x, aiRight.y);
                
                // AI 90-degree paths to King Tower
                ctx.moveTo(aiKing.x - 25, aiKing.y + 25); 
                ctx.lineTo(aiKing.x - 25, aiLeft.y);      
                ctx.lineTo(aiLeft.x, aiLeft.y);           
                
                ctx.moveTo(aiKing.x + 25, aiKing.y + 25); 
                ctx.lineTo(aiKing.x + 25, aiRight.y);     
                ctx.lineTo(aiRight.x, aiRight.y);         


                // Player Paths (Main lanes - 90 deg)
                ctx.moveTo(leftBridge.x, leftBridge.y + 25);
                ctx.lineTo(playerLeft.x, playerLeft.y);
                ctx.moveTo(rightBridge.x, rightBridge.y + 25);
                ctx.lineTo(playerRight.x, playerRight.y);

                // Player 90-degree paths to King Tower
                ctx.moveTo(playerKing.x - 25, playerKing.y - 25); 
                ctx.lineTo(playerKing.x - 25, playerLeft.y);      
                ctx.lineTo(playerLeft.x, playerLeft.y);           

                ctx.moveTo(playerKing.x + 25, playerKing.y - 25); 
                ctx.lineTo(playerKing.x + 25, playerRight.y);     
                ctx.lineTo(playerRight.x, playerRight.y);         
                
                ctx.stroke();
                ctx.lineCap = 'round'; 

                
                // 3. River
                ctx.fillStyle = '#3b82f6'; // Blue
                ctx.fillRect(0, midY - 20, w, 40);
                
                // 4. Bridges
                ctx.fillStyle = '#854d0e'; // Brown
                ctx.fillRect(w / 4 - 25, midY - 25, 50, 50);
                ctx.fillRect(w * 3 / 4 - 25, midY - 25, 50, 50);
                
                // 5. Deployment Zones (–¢–µ–ø–µ—Ä –º–∞–ª—é—î—Ç—å—Å—è –ª–∏—à–µ –ø—É–Ω–∫—Ç–∏—Ä–Ω–∞ –ª—ñ–Ω—ñ—è —Ä—ñ–∫–∏)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.setLineDash([5, 10]);
                ctx.beginPath();
                ctx.moveTo(0, midY);
                ctx.lineTo(w, midY);
                ctx.stroke();
                ctx.setLineDash([]);

                // --- Draw all towers and units ---
                this.getAllTowers().forEach(t => t.draw(this.ctx));
                this.entities.forEach(e => e.draw(this.ctx));
                this.projectiles.forEach(p => p.draw(this.ctx));
                this.effects.forEach(e => e.draw(this.ctx)); 
                
                // *** –ù–û–í–ò–ô –ö–û–î: –ú–∞–ª—é—î–º–æ —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ä–æ–∑–º—ñ—â–µ–Ω–Ω—è ***
                this.drawPlacementIndicator(this.ctx);
                // *** –ö–Ü–ù–ï–¶–¨ –ù–û–í–û–ì–û –ö–û–î–£ ***

                // --- Update UI ---
                elixirBar.style.width = `${(this.playerElixir / ELIXIR_MAX) * 100}%`;
                elixirText.innerText = `${Math.floor(this.playerElixir)} / ${ELIXIR_MAX}`;
                
                document.querySelectorAll('#card-hand .card').forEach(el => {
                    const cardKey = this.playerHand[el.dataset.index];
                    if (cardKey && this.playerElixir < CARD_DECK[cardKey].cost) {
                        el.classList.add('disabled');
                        if (el.classList.contains('selected')) {
                            // Deselect if no longer affordable
                            el.classList.remove('selected');
                            this.selectedCard = null;
                        }
                    } else if (el.classList.contains('disabled')) {
                        el.classList.remove('disabled');
                    }
                });
            }

            // The main game loop
            gameLoop(timestamp) {
                if (!this.animationFrameId) return;
                const deltaTime = (timestamp - this.lastTime) / 1000;
                this.lastTime = timestamp;
                if (this.gameState === GAME_STATE.RUNNING) {
                    this.update(deltaTime || 0);
                }
                this.draw();
                this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
            }

            start() {
                this.initDecks(); 
                
                // RESTORED: click listener
                canvas.addEventListener('click', this.handleCanvasClick.bind(this));
                
                // Keep canvas listeners for cursor tracking
                canvas.addEventListener('mousemove', this.handleCanvasMove.bind(this));
                canvas.addEventListener('mouseleave', this.handleCanvasLeave.bind(this));

                this.lastTime = performance.now();
                this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
            }
            
            stopGame() {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
                
                // Clean up listeners
                canvas.removeEventListener('click', this.handleCanvasClick.bind(this)); 
                canvas.removeEventListener('mousemove', this.handleCanvasMove.bind(this));
                canvas.removeEventListener('mouseleave', this.handleCanvasLeave.bind(this));
            }
            
            // *** RE-ADDED: Full Deployment Logic ***
            isDeploymentAllowed(x, y, cardKey) {
                const card = CARD_DECK[cardKey];
                const cardType = card.type;
                
                const w = canvas.width;
                const h = canvas.height;
                const midY = h / 2;

                // 1. Spells can be placed anywhere
                if (cardType === 'spell') {
                    return true;
                }
                
                // 2. Check for Units/Buildings
                // 2a. Player's side (bottom half)
                if (y > midY) {
                    // Buildings have a restricted zone near the King Tower
                    if (cardType === 'building') {
                        if (y > this.playerKingTower.y - this.playerKingTower.height) {
                            return false; // Too close to King Tower
                        }
                    }
                    return true; // Allowed
                }

                // 2b. We are on the enemy side (y <= midY)
                
                // Buildings cannot be placed on enemy side
                if (cardType === 'building') {
                    return false;
                }
                
                // FORBIDDEN: King Tower Zone (e.g., top 130px)
                const kingTowerZoneY = this.aiKingTower.y + this.aiKingTower.height + 30; // 50 + 50 + 30 = 130
                if (y < kingTowerZoneY) {
                    return false; // Always forbidden
                }
                
                // We are in the "middle" of the enemy side
                const aiLeftDestroyed = !this.aiLeftTower.isAlive;
                const aiRightDestroyed = !this.aiRightTower.isAlive;
                const inLeftLane = (x < w / 2);
                
                // Allow in left lane IF left tower is down
                if (inLeftLane && aiLeftDestroyed) {
                    return true;
                }
                
                // Allow in right lane IF right tower is down
                if (!inLeftLane && aiRightDestroyed) {
                    return true;
                }

                // All other cases (e.g., left lane but left tower is up) are forbidden
                return false;
            }
            // *** END REPLACEMENT ***


            // *** MODIFIED: handleCanvasMove (simplified) ***
            handleCanvasMove(e) {
                this.isCursorOnCanvas = true;
                // –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ 'canvasRect' –∑ –≥–ª–æ–±–∞–ª—å–Ω–æ—ó –æ–±–ª–∞—Å—Ç—ñ
                if (canvasRect) { // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —â–æ canvasRect –≤–∂–µ –≤–∏–∑–Ω–∞—á–µ–Ω–æ
                    this.cursorPosition.x = e.clientX - canvasRect.left;
                    this.cursorPosition.y = e.clientY - canvasRect.top;
                }
            }

            // *** MODIFIED: handleCanvasLeave (simplified) ***
            handleCanvasLeave(e) {
                this.isCursorOnCanvas = false;
            }

pro
            // *** RE-ADDED: Full drawPlacementIndicator logic ***
            drawPlacementIndicator(ctx) {
                // Don't draw if no card is selected or cursor is off-canvas
                if (!this.selectedCard || !this.isCursorOnCanvas) {
                    return; 
                }

                const cardKey = this.selectedCard.key;
                const card = CARD_DECK[cardKey];
                if (!card) return; 
                
                const x = this.cursorPosition.x;
                const y = this.cursorPosition.y;

                // --- 1. Draw Spell Radius ---
                if (card.type === 'spell') {
                    let radiusInPixels = card.stats.range * 25; // 2.5 * 25 = 62.5
                    
                    if (radiusInPixels > 0) {
                        ctx.globalAlpha = 0.4;
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(x, y, radiusInPixels, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.globalAlpha = 1.0;
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(x, y, radiusInPixels, 0, Math.PI * 2);
                        ctx.stroke();

                        ctx.font = 'bold 20px Inter, sans-serif';
                        ctx.fillStyle = 'white';
                        ctx.textAlign = 'center';
                        ctx.shadowColor = 'black';
                        ctx.shadowBlur = 5;
                        ctx.fillText(card.name.toUpperCase(), x, y - radiusInPixels - 15);
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                    }
                } 
                // --- 2. Draw Unit/Building Placement ---
                else if (card.type === 'unit' || card.type === 'building') {
                    const isCurrentSpotAllowed = this.isDeploymentAllowed(x, y, cardKey);
                    const color = isCurrentSpotAllowed ? 'white' : '#ef4444';
                    
                    ctx.globalAlpha = 0.7;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    
                    const tileWidth = 40; 
                    const tileHeight = 40;
                    ctx.strokeRect(x - tileWidth / 2, y - tileHeight / 2, tileWidth, tileHeight);
                    
                    // If hovering a FORBIDDEN spot, show ALL forbidden zones
                    if (!isCurrentSpotAllowed) {
                        const w = canvas.width;
                        const h = canvas.height;
                        const midY = h / 2;
                        
                        ctx.fillStyle = 'rgba(239, 68, 68, 0.4)'; // Red overlay
                        
                        // --- Logic for what is forbidden ---
                        
                        // 1. Buildings
                        if (card.type === 'building') {
                            // Entire enemy side
                            ctx.fillRect(0, 0, w, midY);
                            // Player King Tower zone
                            const playerKingZoneY = this.playerKingTower.y - this.playerKingTower.height;
                            ctx.fillRect(0, playerKingZoneY, w, h - playerKingZoneY);
                        
                        // 2. Normal Units
                        } else {
                            const kingTowerZoneY = this.aiKingTower.y + this.aiKingTower.height + 30; // 130
                            const aiLeftDestroyed = !this.aiLeftTower.isAlive;
                            const aiRightDestroyed = !this.aiRightTower.isAlive;

                            // 2a. King Tower zone
                            ctx.fillRect(0, 0, w, kingTowerZoneY);

                            // 2b. Left Lane zone (if tower is alive)
                            if (!aiLeftDestroyed) {
                                ctx.fillRect(0, kingTowerZoneY, w / 2, midY - kingTowerZoneY);
                            }
                            
                            // 2c. Right Lane zone (if tower is alive)
                            if (!aiRightDestroyed) {
                                ctx.fillRect(w / 2, kingTowerZoneY, w / 2, midY - kingTowerZoneY);
                            }
                        }
                    }
                    
                    ctx.globalAlpha = 1.0;
                }
            }
        }
        
        // --- Init App ---
        switchTab('battle'); // Start on battle tab
        // initCardCollectionUI(); // OLD
        initShopUI();
        // updateBattleDeckUI(); // OLD
        
        renderCardScreen(); // <-- NEW: Call master render function on load
        
    </script>
</body>
</html>
